<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-02-18">

<title>5. Strategies for troubleshooting in R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-b1f392a39194f2101ae5ce2c3ccd3b7e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-3204a54a37e7b2072cd53fe285cb3a4c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../../site_libs/quarto-contrib/live-runtime/live-runtime.js" type="module"></script>
<link href="../../../site_libs/quarto-contrib/live-runtime/live-runtime.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner {
        background: yes;
      }
</style>
<style>
div.callout-todo.callout {
  border-left-color: pink;
}
div.callout-todo.callout-style-default > .callout-header {
  background-color: rgb(from pink r g b / 13%);
}
div.callout-todo .callout-toggle::before {  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgb(33, 37, 41)" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');}
div.callout-todo.callout-style-default .callout-icon::before, div.callout-todo.callout-titled .callout-icon::before {
  content: '📝';
  background-image: none;
}
div.callout-tada.callout {
  border-left-color: #008000;
}
div.callout-tada.callout-style-default > .callout-header {
  background-color: rgba(0, 128, 0, 0.13);
}
div.callout-tada .callout-toggle::before {  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgb(33, 37, 41)" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');}
div.callout-tada.callout-style-default .callout-icon::before, div.callout-tada.callout-titled .callout-icon::before {
  content: '🎉';
  background-image: none;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/editor/editor.main.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer">
<style>
  .monaco-editor pre {
    background-color: unset !important;
  }

  .qwebr-icon-status-spinner {
    color: #7894c4;
  }

  .qwebr-icon-run-code {
    color: #0d9c29
  }

  .qwebr-output-code-stdout {
    color: #111;
  }

  .qwebr-output-code-stderr {
    color: #db4133;
  }

  .qwebr-editor {
    border: 1px solid #EEEEEE;
  }

  .qwebr-button {
    background-color: #EEEEEE;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0; /* Extra styling for consistency */
    display: inline-block;
    font-weight: 400;
    line-height: 1.5;
    color: #000;
    text-align: center;
    text-decoration: none;
    -webkit-text-decoration: none;
    -moz-text-decoration: none;
    -ms-text-decoration: none;
    -o-text-decoration: none;
    /* vertical-align: middle; */ /* Prevents a space from appearing between the code cell and button */
    -webkit-user-select: none;
    border-color: #dee2e6;
    border: 1px solid rgba(0,0,0,0);
    padding: 0.375rem 0.75rem;
    font-size: 1rem;
    border-top-right-radius: 0.25rem;
    border-top-left-radius: 0.25rem;
    transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;
  }

  .qwebr-button:hover {
    color: #000;
    background-color: #e3e6ea;
    border-color: #e1e5e9;
  }

  .qwebr-button:disabled,.qwebr-button.disabled,fieldset:disabled .qwebr-button {
    pointer-events: none;
    opacity: .65
  }

  /* Custom styling for RevealJS Presentations*/

  /* Reset the style of the interactive area */
  .reveal div.qwebr-interactive-area {
    display: block;
    box-shadow: none;
    max-width: 100%;
    max-height: 100%;
    margin: 0;
    padding: 0;
  } 

  /* Provide space to entries */
  .reveal div.qwebr-output-code-area pre div {
    margin: 1px 2px 1px 10px;
  }

  /* Collapse the inside code tags to avoid extra space between line outputs */
  .reveal pre div code.qwebr-output-code-stdout, .reveal pre div code.qwebr-output-code-stderr {
    padding: 0;
    display: contents;
  }

  .reveal pre div code.qwebr-output-code-stdout {
    color: #111;
  }

  .reveal pre div code.qwebr-output-code-stderr {
    color: #db4133;
  }


  /* Create a border around console and output (does not effect graphs) */
  .reveal div.qwebr-console-area {
    border: 1px solid #EEEEEE;
    box-shadow: 2px 2px 10px #EEEEEE;
  }

  /* Cap output height and allow text to scroll */
  /* TODO: Is there a better way to fit contents/max it parallel to the monaco editor size? */
  .reveal div.qwebr-output-code-area pre {
    max-height: 400px;
    overflow: scroll;
  }
</style>

<script type="module">

  // Start a timer
  const initializeWebRTimerStart = performance.now();

  // Determine if we need to install R packages
  var installRPackagesList = [''];
  // Check to see if we have an empty array, if we do set to skip the installation.
  var setupRPackages = !(installRPackagesList.indexOf("") !== -1);
  var autoloadRPackages = true;

  // Display a startup message?
  var showStartupMessage = true;
  var showHeaderMessage = false;
  if (showStartupMessage) {

    // Get references to header elements
    const headerHTML = document.getElementById("title-block-header");
    const headerRevealJS = document.getElementById("title-slide");

    // Create the outermost div element for metadata
    const quartoTitleMeta = document.createElement("div");
    quartoTitleMeta.classList.add("quarto-title-meta");

    // Create the first inner div element
    const firstInnerDiv = document.createElement("div");
    firstInnerDiv.setAttribute("id", "qwebr-status-message-area");

    // Create the second inner div element for "WebR Status" heading and contents
    const secondInnerDiv = document.createElement("div");
    secondInnerDiv.setAttribute("id", "qwebr-status-message-title");
    secondInnerDiv.classList.add("quarto-title-meta-heading");
    secondInnerDiv.innerText = "WebR Status";

    // Create another inner div for contents
    const secondInnerDivContents = document.createElement("div");
    secondInnerDivContents.setAttribute("id", "qwebr-status-message-body");
    secondInnerDivContents.classList.add("quarto-title-meta-contents");

    // Describe the WebR state
    var startupMessageWebR = document.createElement("p");
    startupMessageWebR.innerText = "🟡 Loading...";
    startupMessageWebR.setAttribute("id", "qwebr-status-message-text");
    // Add `aria-live` to auto-announce the startup status to screen readers
    startupMessageWebR.setAttribute("aria-live", "assertive");

    // Append the startup message to the contents
    secondInnerDivContents.appendChild(startupMessageWebR);

    // Add a status indicator for COOP and COEP Headers if needed
    if (showHeaderMessage) {
      const crossOriginMessage = document.createElement("p");
      crossOriginMessage.innerText = `${crossOriginIsolated ? '🟢' : '🟡'} COOP & COEP Headers`;
      crossOriginMessage.setAttribute("id", "qwebr-coop-coep-header");
      secondInnerDivContents.appendChild(crossOriginMessage);
    }

    // Combine the inner divs and contents
    firstInnerDiv.appendChild(secondInnerDiv);
    firstInnerDiv.appendChild(secondInnerDivContents);
    quartoTitleMeta.appendChild(firstInnerDiv);

    // Determine where to insert the quartoTitleMeta element
    if (headerHTML) {
      // Append to the existing "title-block-header" element
      headerHTML.appendChild(quartoTitleMeta);
    } else if (headerRevealJS) {
      // If using RevealJS, add to the "title-slide" div
      headerRevealJS.appendChild(firstInnerDiv);
    } else {
      // If neither headerHTML nor headerRevealJS is found, insert after "webr-monaco-editor-init" script
      const monacoScript = document.getElementById("qwebr-monaco-editor-init");
      const header = document.createElement("header");
      header.setAttribute("id", "title-block-header");
      header.appendChild(quartoTitleMeta);
      monacoScript.after(header);
    }
  }

  // Retrieve the webr.mjs
  import { WebR, ChannelType } from "https://webr.r-wasm.org/v0.2.2/webr.mjs";

  // Populate WebR options with defaults or new values based on 
  // webr meta
  globalThis.webR = new WebR({
    "baseURL": "https://webr.r-wasm.org/v0.2.2/",
    "serviceWorkerUrl": "",
    "homedir": "/home/web_user", 
    "channelType": ChannelType.Automatic
  });

  // Initialization WebR
  await globalThis.webR.init();

  // Setup a shelter
  globalThis.webRCodeShelter = await new globalThis.webR.Shelter();

  // Setup a pager to allow processing help documentation 
  await globalThis.webR.evalRVoid('webr::pager_install()'); 

  // Function to set the button text
  function qwebrSetInteractiveButtonState(buttonText, enableCodeButton = true) {
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.innerHTML = buttonText;
      btn.disabled = !enableCodeButton;
    });
    document.querySelectorAll(".qwebr-button-check").forEach((btn) => {
      btn.disabled = !enableCodeButton;
    });
  }

  // Function to update the status message
  function qwebrUpdateStatusHeader(message) {
    startupMessageWebR.innerHTML = `
      <i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i>
      <span>${message}</span>`;
  }

  // Function to install a single package
  async function qwebrInstallRPackage(packageName) {
    await globalThis.webR.installPackages([packageName]);
  }

  // Function to load a single package
  async function qwebrLoadRPackage(packageName) {
    await globalThis.webR.evalRVoid(`library(${packageName});`);
  }

  // Generic function to process R packages
  async function qwebrProcessRPackagesWithStatus(packages, processType, displayStatusMessageUpdate = true) {
    // Switch between contexts
    const messagePrefix = processType === 'install' ? 'Installing' : 'Loading';

    // Modify button state
    qwebrSetInteractiveButtonState(`🟡 ${messagePrefix} package ...`, false);

    // Iterate over packages
    for (let i = 0; i < packages.length; i++) {
      const activePackage = packages[i];
      const formattedMessage = `${messagePrefix} package ${i + 1} out of ${packages.length}: ${activePackage}`;
      
      // Display the update
      if (displayStatusMessageUpdate) {
        qwebrUpdateStatusHeader(formattedMessage);
      }

      // Run package installation
      if (processType === 'install') {
        await qwebrInstallRPackage(activePackage);
      } else {
        await qwebrLoadRPackage(activePackage);
      }
    }

    // Clean slate
    if (processType === 'load') {
      await globalThis.webR.flush();
    }
  }


  // Override the existing install.packages() to use webr::install()
  await globalThis.webR.evalRVoid('webr::shim_install()'); 


  // Check to see if any packages need to be installed
  if (setupRPackages) {
    // Obtain only a unique list of packages
    const uniqueRPackageList = Array.from(new Set(installRPackagesList));

    // Install R packages one at a time (either silently or with a status update)
    await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'install', showStartupMessage);

    if(autoloadRPackages) {
      // Load R packages one at a time (either silently or with a status update)
      await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'load', showStartupMessage);
    }
  }
  
  // Setup answer checking functions
  await globalThis.webR.evalRVoid(
`options(max.print = 100)
.printed <- list()
.errored <- character()
.warned <- character()
print <- function(x, ...) {
  .printed[[length(.printed) + 1]] <<- x
  base:::print(x, ...)
}
capture_printed <- function(x) {
  x_vis <- withVisible(
    tryCatch(x, 
      error = function(e) {
        message("Error: ", e$message)
        .errored[[length(.errored) + 1]] <<- e$message
      },
      finally = list(visible = FALSE, value = NULL)
    )
  )
  if(x_vis$visible) print(x_vis$value) else invisible()
}

compare_args <- function(x, y) {
  val <- match(x, y)
  if(any(is.na(val))) return(FALSE)
  identical(names(x), names(y)[val])
}

search_ast_impl <- function(.code, fn = NULL, fn_args = list()) {
  if(!(is.call(.code) || is.expression(.code))) return(FALSE)
  args <- as.list(.code[-1])
  if(compare_args(fn_args, args)) {
    if(is.null(fn) || identical(fn, .code[[1]])) return(TRUE)
  }
  
  any(vapply(args, search_ast_impl, logical(1L), fn = fn, fn_args = fn_args))
}

search_ast <- function(.code, .fn = NULL, ..., .expr = NULL) {
  .expr <- substitute(.expr)
  if(!is.null(.expr)) {
    .fn <- .expr[[1]]
    fn_args <- as.list(.expr[-1])
  } else {
    .fn <- substitute(.fn)
    fn_args <- as.list(substitute(...()))
  }
  
  if(is.expression(.code)) .code <- as.list(.code)
  any(vapply(.code, search_ast_impl, logical(1L), fn = .fn, fn_args = fn_args))
}

exists_in <- function(.x, .f, ..., .require = any) {
  if(inherits(.f, "formula")) {
    f <- .f
    .f <- function(.x, .y, ..., . = .x) {}
    body(.f) <- f[[length(f)]]
  }
  .require(vapply(.x, .f, logical(1L), ...))
}

check_answer <- function(.code) {
  .printed <<- list()
  .errored <<- character()
  .warned <<- character()
  .src <- .code
  .code <- parse(text = .src)
  .exec <- as.expression(lapply(.code, function(l) call("capture_printed", l)))
  eval(.exec, envir = .GlobalEnv)
  results <- teachr_tests(.code, .printed, .errored, .warned)
  if(all(!results)) {
    cat("✅ That's correct! Well done 🎉", "\n", sep = "", file = stdout(), append = TRUE)
  } else {
    cat("❌ That's incorrect! Please try again...", "\n", sep = "", file = stdout(), append = TRUE)
    cat(paste("•", names(results)[results]), sep = "\n", file = stdout(), append = TRUE)
  }
  invisible()
}`
  );

  // Stop timer
  const initializeWebRTimerEnd = performance.now();

  // Release document status as ready
  if (showStartupMessage) {
    startupMessageWebR.innerText = "🟢 Ready!"
  }
  
  qwebrSetInteractiveButtonState(
    `<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run code</span>`, 
    true
  );

  // Global version of the Escape HTML function that converts HTML 
  // characters to their HTML entities.
  globalThis.qwebrEscapeHTMLCharacters = function(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  };
</script>


</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">StartR</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Courses</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">5. Strategies for troubleshooting in R</h1>
            <p class="subtitle lead">With coding comes bugs and errors that need troubleshooting. In this chapter, you will learn how to decipher errors, find help for fixing them, and practice asking clear questions with minimally reproducible examples.</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">18 February 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-are-error-messages" id="toc-what-are-error-messages" class="nav-link active" data-scroll-target="#what-are-error-messages">What are error messages?</a></li>
  <li><a href="#read-the-error" id="toc-read-the-error" class="nav-link" data-scroll-target="#read-the-error">Read the error</a>
  <ul class="collapse">
  <li><a href="#lets-have-a-look-at-some-common-error-messages" id="toc-lets-have-a-look-at-some-common-error-messages" class="nav-link" data-scroll-target="#lets-have-a-look-at-some-common-error-messages">Let’s have a look at some common error messages</a></li>
  <li><a href="#what-if-we-cannot-find-the-function" id="toc-what-if-we-cannot-find-the-function" class="nav-link" data-scroll-target="#what-if-we-cannot-find-the-function">What if we cannot find the function?!</a></li>
  <li><a href="#search-the-message" id="toc-search-the-message" class="nav-link" data-scroll-target="#search-the-message">Search the message 🔎</a></li>
  <li><a href="#divide-and-conquer" id="toc-divide-and-conquer" class="nav-link" data-scroll-target="#divide-and-conquer">Divide and conquer 💪</a></li>
  <li><a href="#turn-it-off-and-on-again" id="toc-turn-it-off-and-on-again" class="nav-link" data-scroll-target="#turn-it-off-and-on-again">Turn it off and on again 🔄</a></li>
  </ul></li>
  <li><a href="#asking-for-help" id="toc-asking-for-help" class="nav-link" data-scroll-target="#asking-for-help">Asking for help</a>
  <ul class="collapse">
  <li><a href="#describe-the-problem" id="toc-describe-the-problem" class="nav-link" data-scroll-target="#describe-the-problem">Describe the problem</a></li>
  <li><a href="#provide-a-minimal-reproducible-example" id="toc-provide-a-minimal-reproducible-example" class="nav-link" data-scroll-target="#provide-a-minimal-reproducible-example">Provide a minimal reproducible example</a></li>
  <li><a href="#where-to-ask-for-help" id="toc-where-to-ask-for-help" class="nav-link" data-scroll-target="#where-to-ask-for-help">Where to ask for help</a></li>
  </ul></li>
  <li><a href="#minimal-reproducible-examples" id="toc-minimal-reproducible-examples" class="nav-link" data-scroll-target="#minimal-reproducible-examples">Minimal Reproducible Examples</a>
  <ul class="collapse">
  <li><a href="#providing-minimal-datasets" id="toc-providing-minimal-datasets" class="nav-link" data-scroll-target="#providing-minimal-datasets">Providing minimal datasets</a></li>
  <li><a href="#create-minimal-reproducible-examples" id="toc-create-minimal-reproducible-examples" class="nav-link" data-scroll-target="#create-minimal-reproducible-examples">Create minimal reproducible examples</a></li>
  <li><a href="#provide-session-information" id="toc-provide-session-information" class="nav-link" data-scroll-target="#provide-session-information">Provide session information</a></li>
  <li><a href="#using-the-reprex-package-for-producing-examples" id="toc-using-the-reprex-package-for-producing-examples" class="nav-link" data-scroll-target="#using-the-reprex-package-for-producing-examples">Using the <code>reprex</code> package for producing examples</a></li>
  </ul></li>
  <li><a href="#asking-for-help-checklist" id="toc-asking-for-help-checklist" class="nav-link" data-scroll-target="#asking-for-help-checklist">Asking for help checklist ☑️</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/loader.js"></script>
<script type="module" id="qwebr-monaco-editor-init">

  // Configure the Monaco Editor's loader
  require.config({
    paths: {
      'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs'
    }
  });
</script>





<section id="what-are-error-messages" class="level1">
<h1>What are error messages?</h1>
<p>Eek! There’s a bug in my code and it’s causing lots of <span style="color: red;">scary red errors</span>!</p>
<p>Don’t panic - believe it or not, this error is just trying to help you! It also may have just saved you from invalid results that you may not have have noticed.</p>
<p>Errors can be frustrating, essentially you’ve just asked the computer to do something and it has said no!</p>
<p>There are a few troubleshooting techniques that we can use to find the source of the error, modify your code, and get the results you’re looking for.</p>
</section>
<section id="read-the-error" class="level1">
<h1>Read the error</h1>
<p>The first step is to carefully <strong>read</strong> the error message, it often contains clues into where and why the code didn’t run. With some time and experience, you’ll begin to identify these errors and fix your code quickly based on the message alone!</p>
<section id="lets-have-a-look-at-some-common-error-messages" class="level2">
<h2 class="anchored" data-anchor-id="lets-have-a-look-at-some-common-error-messages">Let’s have a look at some common error messages</h2>
<div id="qwebr-interactive-area-1" class="qwebr-interactive-area">
  <button class="btn btn-default qwebr-button qwebr-button-run" disabled="" type="button" id="qwebr-button-run-1">🟡 Loading
    webR...</button>
  <button class="btn btn-default qwebr-button qwebr-button-check" disabled="" type="button" id="qwebr-button-check-1">💡 Check answer</button>
  <button class="btn btn-default qwebr-button qwebr-button-solve" type="button" id="qwebr-button-solve-1">✅ Show solution</button>
  <button class="btn btn-default qwebr-button qwebr-button-reset" type="button" id="qwebr-button-reset-1">💥 Reset code</button>
  <div id="qwebr-console-area-1" class="qwebr-console-area">
    <div id="qwebr-editor-1" class="qwebr-editor"></div>
    <div id="qwebr-output-code-area-1" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-1" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-1");
  const checkButton = document.getElementById("qwebr-button-check-1");
  const solveButton = document.getElementById("qwebr-button-solve-1");
  const resetButton = document.getElementById("qwebr-button-reset-1");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-1");
  const editorDiv = document.getElementById("qwebr-editor-1");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-1");
  const webrCode = `# Lets look at the penguins data from the palmerpenguins package
# Lets take a look at the structure
str(penguins)`

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: webrCode,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           // TODO: Could be problematic for slide decks
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      fontSize: '17.5pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true  // Remove cursor indictor in right hand side scroll bar
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = true;
    });

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-1-result-${index + 1}" class="${className}">${qwebrEscapeHTMLCharacters(evt.data)}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "700px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-1-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = false;
    });
    
    // Revert to the initial code cell state
    runButton.innerHTML = '<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run code</span>';
    checkButton.innerHTML = '💡 Check answer';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    // Emphasize the active code cell
    runButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Run code</span>';
    executeCode(editor.getValue());
  };
  
  checkButton.onclick = function () {
    // Emphasize the active code cell
    checkButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Check answer</span>';
    executeCode(
`teachr_tests <- function(.code, .printed, .errored, .warned) {
  TRUE
}
check_answer(r"(` + editor.getValue() + `)")`
    );
  };
  
  solveButton.onclick = function () {
    editor.setValue(`# Lets look at the penguins data from the palmerpenguins package
# Lets take a look at the structure
str(penguins)`);
  };
  
  resetButton.onclick = function () {
    editor.setValue(webrCode);
  };
</script>
<p>Oh no! An error message: <span style="color: red;">“Error: object ‘palmerpenguins’ not found”</span>!</p>
<p>When you see the error message <span style="color: red;">“Error: object ‘_____’ not found”</span>, it usually means there is a typo or the object wasn’t loaded in correctly. In this instance, we haven’t used the correct object. Let’s look at how we can fix this.</p>
<div id="qwebr-interactive-area-2" class="qwebr-interactive-area">
  <button class="btn btn-default qwebr-button qwebr-button-run" disabled="" type="button" id="qwebr-button-run-2">🟡 Loading
    webR...</button>
  <button class="btn btn-default qwebr-button qwebr-button-check" disabled="" type="button" id="qwebr-button-check-2">💡 Check answer</button>
  <button class="btn btn-default qwebr-button qwebr-button-solve" type="button" id="qwebr-button-solve-2">✅ Show solution</button>
  <button class="btn btn-default qwebr-button qwebr-button-reset" type="button" id="qwebr-button-reset-2">💥 Reset code</button>
  <div id="qwebr-console-area-2" class="qwebr-console-area">
    <div id="qwebr-editor-2" class="qwebr-editor"></div>
    <div id="qwebr-output-code-area-2" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-2" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-2");
  const checkButton = document.getElementById("qwebr-button-check-2");
  const solveButton = document.getElementById("qwebr-button-solve-2");
  const resetButton = document.getElementById("qwebr-button-reset-2");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-2");
  const editorDiv = document.getElementById("qwebr-editor-2");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-2");
  const webrCode = `# Let's try to have a look at the structure of the penguins data set
# We will first load in the palmerpenguins package
library(palmerpenguins)
str(___)
  `

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: webrCode,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           // TODO: Could be problematic for slide decks
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      fontSize: '17.5pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true  // Remove cursor indictor in right hand side scroll bar
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = true;
    });

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-2-result-${index + 1}" class="${className}">${qwebrEscapeHTMLCharacters(evt.data)}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "700px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-2-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = false;
    });
    
    // Revert to the initial code cell state
    runButton.innerHTML = '<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run code</span>';
    checkButton.innerHTML = '💡 Check answer';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    // Emphasize the active code cell
    runButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Run code</span>';
    executeCode(editor.getValue());
  };
  
  checkButton.onclick = function () {
    // Emphasize the active code cell
    checkButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Check answer</span>';
    executeCode(
`teachr_tests <- function(.code, .printed, .errored, .warned) {
  
p <- .code[[1]][[2]][[2]]
  
c("did you put in penguins?" = !"penguins" %in% all.vars(.code))
}
check_answer(r"(` + editor.getValue() + `)")`
    );
  };
  
  solveButton.onclick = function () {
    editor.setValue(`# Let's try to have a look at the structure of the penguins data set
# We will first load in the palmerpenguins package
library(palmerpenguins)
str(penguins)
  `);
  };
  
  resetButton.onclick = function () {
    editor.setValue(webrCode);
  };
</script>
<p>Typos are a common error, whether it’s in the object name or the function name. In this example, we accidentally used the package name, instead of the name of the data from within the package. When you see the error message <span style="color: red;">“Error: object ‘_____’ not found”</span>, please check and make sure that everything is inputted correctly and the relevant packages are loaded in.</p>
</section>
<section id="what-if-we-cannot-find-the-function" class="level2">
<h2 class="anchored" data-anchor-id="what-if-we-cannot-find-the-function">What if we cannot find the function?!</h2>
<div id="qwebr-interactive-area-3" class="qwebr-interactive-area">
  <button class="btn btn-default qwebr-button qwebr-button-run" disabled="" type="button" id="qwebr-button-run-3">🟡 Loading
    webR...</button>
  <button class="btn btn-default qwebr-button qwebr-button-check" disabled="" type="button" id="qwebr-button-check-3">💡 Check answer</button>
  <button class="btn btn-default qwebr-button qwebr-button-solve" type="button" id="qwebr-button-solve-3">✅ Show solution</button>
  <button class="btn btn-default qwebr-button qwebr-button-reset" type="button" id="qwebr-button-reset-3">💥 Reset code</button>
  <div id="qwebr-console-area-3" class="qwebr-console-area">
    <div id="qwebr-editor-3" class="qwebr-editor"></div>
    <div id="qwebr-output-code-area-3" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-3" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-3");
  const checkButton = document.getElementById("qwebr-button-check-3");
  const solveButton = document.getElementById("qwebr-button-solve-3");
  const resetButton = document.getElementById("qwebr-button-reset-3");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-3");
  const editorDiv = document.getElementById("qwebr-editor-3");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-3");
  const webrCode = `# Let's try to have a look at the structure of the penguins dataset
# Instead of the base R function of checking structure for your dataset, let's use dplyr function glance to do that. 

glimpse(penguins)
  `

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: webrCode,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           // TODO: Could be problematic for slide decks
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      fontSize: '17.5pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true  // Remove cursor indictor in right hand side scroll bar
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = true;
    });

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-3-result-${index + 1}" class="${className}">${qwebrEscapeHTMLCharacters(evt.data)}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "700px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-3-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = false;
    });
    
    // Revert to the initial code cell state
    runButton.innerHTML = '<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run code</span>';
    checkButton.innerHTML = '💡 Check answer';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    // Emphasize the active code cell
    runButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Run code</span>';
    executeCode(editor.getValue());
  };
  
  checkButton.onclick = function () {
    // Emphasize the active code cell
    checkButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Check answer</span>';
    executeCode(
`teachr_tests <- function(.code, .printed, .errored, .warned) {
  
  
}
check_answer(r"(` + editor.getValue() + `)")`
    );
  };
  
  solveButton.onclick = function () {
    editor.setValue(`# Let's try to have a look at the structure of the penguins dataset
# Instead of the base R function of checking structure for your dataset, let's use dplyr function glance to do that. 

glimpse(penguins)
  `);
  };
  
  resetButton.onclick = function () {
    editor.setValue(webrCode);
  };
</script>
<p>Oh no, we could not find the function of <code>glimpse()</code>! We’ve checked the spelling, so what could be the problem now?</p>
<p>When you see the error message <span style="color: red;">“Error: could not find function”_____”</span>, it usually means the required package hasn’t been loaded into environment.</p>
<p>Let’s try add in the required package <code>dplyr</code></p>
<div id="qwebr-interactive-area-4" class="qwebr-interactive-area">
  <button class="btn btn-default qwebr-button qwebr-button-run" disabled="" type="button" id="qwebr-button-run-4">🟡 Loading
    webR...</button>
  <button class="btn btn-default qwebr-button qwebr-button-check" disabled="" type="button" id="qwebr-button-check-4">💡 Check answer</button>
  <button class="btn btn-default qwebr-button qwebr-button-solve" type="button" id="qwebr-button-solve-4">✅ Show solution</button>
  <button class="btn btn-default qwebr-button qwebr-button-reset" type="button" id="qwebr-button-reset-4">💥 Reset code</button>
  <div id="qwebr-console-area-4" class="qwebr-console-area">
    <div id="qwebr-editor-4" class="qwebr-editor"></div>
    <div id="qwebr-output-code-area-4" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-4" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-4");
  const checkButton = document.getElementById("qwebr-button-check-4");
  const solveButton = document.getElementById("qwebr-button-solve-4");
  const resetButton = document.getElementById("qwebr-button-reset-4");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-4");
  const editorDiv = document.getElementById("qwebr-editor-4");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-4");
  const webrCode = `
# Let's try to have a look at the structure of the penguins dataset 
# Instead of the base R function of checking structure for your dataset, let's use dplyr function glimpse to do that. 

library(___)
glimpse(penguins)
  `

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: webrCode,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           // TODO: Could be problematic for slide decks
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      fontSize: '17.5pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true  // Remove cursor indictor in right hand side scroll bar
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = true;
    });

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-4-result-${index + 1}" class="${className}">${qwebrEscapeHTMLCharacters(evt.data)}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "700px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-4-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = false;
    });
    
    // Revert to the initial code cell state
    runButton.innerHTML = '<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run code</span>';
    checkButton.innerHTML = '💡 Check answer';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    // Emphasize the active code cell
    runButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Run code</span>';
    executeCode(editor.getValue());
  };
  
  checkButton.onclick = function () {
    // Emphasize the active code cell
    checkButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Check answer</span>';
    executeCode(
`teachr_tests <- function(.code, .printed, .errored, .warned) {
  
  c(
  "Did you load in the dplyr package in library()?" = !search_ast(.code, .expr = library(dplyr)
)

  
}
check_answer(r"(` + editor.getValue() + `)")`
    );
  };
  
  solveButton.onclick = function () {
    editor.setValue(`
# Let's try to have a look at the structure of the penguins dataset 
# Instead of the base R function of checking structure for your dataset, let's use dplyr function glimpse to do that. 

library(dplyr)
glimpse(penguins)
  `);
  };
  
  resetButton.onclick = function () {
    editor.setValue(webrCode);
  };
</script>
<p>Sometimes, reading the error message can be a bit tricky. If you’re not sure what the error message is trying to tell you, don’t worry! We’ll cover some other strategies.</p>
</section>
<section id="search-the-message" class="level2">
<h2 class="anchored" data-anchor-id="search-the-message">Search the message 🔎</h2>
<p><strong>Often,</strong> error messages can be confusing, and even after carefully reading the message it may be difficult to ascertain what the problem is.</p>
<p>Chances are you’re not the first person to encounter this problem and there’s a well explained solution waiting for you on the internet - you just need to find it.</p>
<p>Take this <a href="https://www.youtube.com/watch?v=vgYS-F8opgE">notoriously confusing error</a> for example. In this code, I want to see the first few values of my <code>sample</code> object. Try running the code below:</p>
<div id="qwebr-interactive-area-5" class="qwebr-interactive-area">
  <button class="btn btn-default qwebr-button qwebr-button-run" disabled="" type="button" id="qwebr-button-run-5">🟡 Loading
    webR...</button>
  <button class="btn btn-default qwebr-button qwebr-button-check" disabled="" type="button" id="qwebr-button-check-5">💡 Check answer</button>
  <button class="btn btn-default qwebr-button qwebr-button-solve" type="button" id="qwebr-button-solve-5">✅ Show solution</button>
  <button class="btn btn-default qwebr-button qwebr-button-reset" type="button" id="qwebr-button-reset-5">💥 Reset code</button>
  <div id="qwebr-console-area-5" class="qwebr-console-area">
    <div id="qwebr-editor-5" class="qwebr-editor"></div>
    <div id="qwebr-output-code-area-5" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-5" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-5");
  const checkButton = document.getElementById("qwebr-button-check-5");
  const solveButton = document.getElementById("qwebr-button-solve-5");
  const resetButton = document.getElementById("qwebr-button-reset-5");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-5");
  const editorDiv = document.getElementById("qwebr-editor-5");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-5");
  const webrCode = `
sample[1:3]
  `

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: webrCode,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           // TODO: Could be problematic for slide decks
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      fontSize: '17.5pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true  // Remove cursor indictor in right hand side scroll bar
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = true;
    });

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-5-result-${index + 1}" class="${className}">${qwebrEscapeHTMLCharacters(evt.data)}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "700px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-5-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = false;
    });
    
    // Revert to the initial code cell state
    runButton.innerHTML = '<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run code</span>';
    checkButton.innerHTML = '💡 Check answer';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    // Emphasize the active code cell
    runButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Run code</span>';
    executeCode(editor.getValue());
  };
  
  checkButton.onclick = function () {
    // Emphasize the active code cell
    checkButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Check answer</span>';
    executeCode(
`teachr_tests <- function(.code, .printed, .errored, .warned) {
  
  
}
check_answer(r"(` + editor.getValue() + `)")`
    );
  };
  
  solveButton.onclick = function () {
    editor.setValue(`
sample[1:3]
  `);
  };
  
  resetButton.onclick = function () {
    editor.setValue(webrCode);
  };
</script>
<p><span style="color: red;">“Error: object of type ‘closure’ is not subsettable”</span></p>
<p>What is a <em>‘closure’</em>? Why can’t I subset my data with <code>x[1:3]</code>?</p>
<p>When confronted with an error you’ve never seen, and don’t understand - search the web! Just copy the error exactly, “object of type ‘closure’ is not subsettable”, add some relevant keywords like “R” and search!</p>
<p>With some luck, you’ll be met with a series of StackOverflow threads, blog posts and other websites explaining the solution to the exact problem you’re facing. Here’s my top 3 search results:</p>
<ul>
<li><a href="https://coolbutuseless.github.io/2019/02/12/object-of-type-closure-is-not-subsettable/" class="uri">https://coolbutuseless.github.io/2019/02/12/object-of-type-closure-is-not-subsettable/</a></li>
<li><a href="https://stackoverflow.com/questions/11308367/error-in-my-code-object-of-type-closure-is-not-subsettable" class="uri">https://stackoverflow.com/questions/11308367/error-in-my-code-object-of-type-closure-is-not-subsettable</a></li>
<li><a href="https://www.r-bloggers.com/2019/02/object-of-type-closure-is-not-subsettable/" class="uri">https://www.r-bloggers.com/2019/02/object-of-type-closure-is-not-subsettable/</a></li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tips for searching errors online
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>1.</strong> Add double quotes around the error message. This searches for those exact words in that exact order.</p>
<p><strong>2.</strong> For long error messages, just search for the unique sounding parts (don’t include parts specific to your code, like a variable name)</p>
<p><strong>3.</strong> Add keywords to describe your code’s language, like ‘R’.</p>
<p><strong>4.</strong> If you’re looking for solutions on a specific website, add <code>site:&lt;domain&gt;</code> to the search. For example, <code>site:stackoverflow.com</code>.</p>
</div>
</div>
</section>
<section id="divide-and-conquer" class="level2">
<h2 class="anchored" data-anchor-id="divide-and-conquer">Divide and conquer 💪</h2>
<p>If you understand the message, but have no idea where the problem stems from - try running smaller sections of your code to see if that small section causes the error. Once you identify the small section of code causing the error, it should be slightly easier to find the issue in your code.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Running into this issue often?
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you frequently use this strategy, it may indicate a code styling issue. Consider breaking your code into smaller pieces instead of trying to do everything in one line. For tips on good coding practices, see <a href="https://www.youtube.com/watch?v=7oyiPBjLAWY">Jenny Bryan’s presentation ’Code Smells and Feels</a>.</p>
</div>
</div>
</section>
<section id="turn-it-off-and-on-again" class="level2">
<h2 class="anchored" data-anchor-id="turn-it-off-and-on-again">Turn it off and on again 🔄</h2>
<p>The age old classic (but sometimes it really does work!).</p>
<p>In R, you don’t necessarily need to restart your <em>whole</em> computer, but instead you can try restarting RStudio, or your R session. Usually I would restart R, which can be done in RStudio</p>
<p>This can be done in two ways:</p>
<ol type="1">
<li>‘Session’ on the top menu bar, then ‘Restart R’</li>
<li><code>Ctrl + Shift + F10</code> (Windows) or <code>Cmd + Shift + F10</code> (Mac)</li>
</ol>
<p>There are a few reasons why this can work. It allows you to re-run your code from a clean slate, with no extra packages loaded that you haven’t asked for and no extra objects in your environment.</p>
</section>
</section>
<section id="asking-for-help" class="level1">
<h1>Asking for help</h1>
<p>Once you’ve carefully read the error, searched the web, and tried everything else you can think of, it’s time to ask for help. However for a stranger to take time out of their day to find the solution and write a good answer for you, you better have written a good question for them!</p>
<div style="text-align: center;">
<p><img src="images/bad_question.png" alt="Bad Question" width="600"></p>
</div>
<p>Read ahead to find out why this is an example of a <strong>bad question</strong>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Good Questions
</div>
</div>
<div class="callout-body-container callout-body">
<p>A <strong>good question</strong> consists of a <strong>clear and concise</strong> description of your problem, and a <strong>small example</strong> that can be used to reproduce the issue.</p>
</div>
</div>
<section id="describe-the-problem" class="level2">
<h2 class="anchored" data-anchor-id="describe-the-problem">Describe the problem</h2>
<p>A good description provides some context to your question. When writing your question, think about what you are trying to achieve.</p>
<p>Instead of writing generic phrases like “it doesn’t work” or “it shows errors,” provide more detailed information about your issue.</p>
<ul>
<li><p>Clearly state your goal and the expected output.</p></li>
<li><p>Include the exact wording of any error messages you receive.</p></li>
<li><p>Use a descriptive title that summarises your problem succinctly.</p></li>
</ul>
</section>
<section id="provide-a-minimal-reproducible-example" class="level2">
<h2 class="anchored" data-anchor-id="provide-a-minimal-reproducible-example">Provide a minimal reproducible example</h2>
<p>A minimal reproducible example is the smallest amount of code that still produces the error. This step is so important that we’ve dedicated an entire section to writing good examples. An example allows the person helping you to quickly understand the issue you are facing, and make changes directly to your example to demonstrate the solution.</p>
<p>The process of creating an example, and reducing it down into the minimal amount of code you can to produce the error, often results in you finding the solution yourself.</p>
</section>
<section id="where-to-ask-for-help" class="level2">
<h2 class="anchored" data-anchor-id="where-to-ask-for-help">Where to ask for help</h2>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td><a href="https://stackoverflow.com/questions/tagged/rstudio"><strong>Stack Overflow.</strong></a></td>
<td>This is a platform where you can search for solutions and ask for help. Before asking a question on Stack Overflow, you can search some key words from your understanding of error messages. It is likely that people have already asked similar questions related to your error and you can try the solutions provided by others under the question.</td>
</tr>
<tr class="even">
<td><a href="https://forum.posit.co/"><strong>RStudio Community.</strong></a></td>
<td>This is a community channel for RStudio users. Similar to Stack Overflow, you can ask questions and also find solutions.</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/"><strong>GitHub.</strong></a></td>
<td><p>If you’ve thoroughly investigated your error and believe the issue lies in the package rather than your code, you can contact the package’s developer. Most R packages are open-source and maintained on Github.</p>
<p>1. Search for the package’s repository using its name along with “R” and “GitHub”.</p>
<p>2. Use the “Issues” tab to report your problem.</p>
<p>3. Make sure to check if the issue has already been reported before creating a new one.</p></td>
</tr>
<tr class="even">
<td><strong>Discussion Forum on Moodle or</strong> <a href="http://edstem.org"><strong>Ed.</strong></a></td>
<td><p>If you’re preparing for your Monash University course, a good place to ask for help is the discussion forum on Moodle. You can also seek assistance from your lecturers and tutors.</p>
<ul>
<li>If your unit uses Ed as a discussion space, use it to ask or answer questions. Some units may even allow you to post privately or anonymously if you feel shy posting publicly.</li>
</ul></td>
</tr>
<tr class="odd">
<td><strong>Trusty (sometimes) AI.</strong></td>
<td>There are many AI tools that can help you write code, and some can even help you debug it. However, AI should be used with caution. While it can assist in troubleshooting errors, it may not always provide the best solution. You should still try to understand what the code is doing and why it’s causing an error to avoid using code from AI which may be producing inaccurate results (despite running without error).</td>
</tr>
<tr class="even">
<td><strong>Teachers and Tutors in Consultations.</strong></td>
<td><p>Ask your lecturers and tutors for help during consultation sessions, which are available for any content-related difficulties, including debugging code.</p>
<ul>
<li>Prepare a small demonstration of your error beforehand to make the session more effective.</li>
<li>The benefit of these sessions is that we can guide you closer to the solution until you figure it out yourself.</li>
<li>Don’t be disheartened if your error, which you’ve struggled with for hours, is solved in minutes — we’ve had plenty of practice (also being stuck for hours) troubleshooting these errors.</li>
</ul></td>
</tr>
</tbody>
</table>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Help and Learn
</div>
</div>
<div class="callout-body-container callout-body">
<p>Answering questions on the forum can help consolidate your understanding and prepare you for asking and answering questions in other forums such as Stack Overflow.</p>
</div>
</div>
</section>
</section>
<section id="minimal-reproducible-examples" class="level1">
<h1>Minimal Reproducible Examples</h1>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Remember
</div>
</div>
<div class="callout-body-container callout-body">
<p>A minimally reproducible example (often called an MRE) contains all of the code necessary for someone else to encounter the same error you’re facing.</p>
</div>
</div>
<p>To create one, you need to provide the <strong>exact packages you’re using</strong>, some <strong>data</strong> if needed, and <strong>your code.</strong> A good example is also <strong>minimal</strong>, which means that you’ve taken the time to remove as much unrelated packages, code and data as possible to produce the error.</p>
<section id="providing-minimal-datasets" class="level2">
<h2 class="anchored" data-anchor-id="providing-minimal-datasets">Providing minimal datasets</h2>
<p>If your question involves using a dataset, you will need to provide a small dataset to demonstrate the problem. Often people say that the data is confidential and can’t be provided, but usually the problem isn’t specific to the data you are using. Taking the time to try your code on a different dataset is a good debugging step, and R provides many good datasets to use in these examples built in. You can find a complete list of datasets available to all R users with the <code>data(package = "datasets")</code> function.</p>
<p>If you do need to use a custom dataset specific to your project, try reducing the size of the dataset before making your example. The error may only occur for some specific rows of your data. Once you’ve narrowed in on the issue, you can convert your minimal data object to code for producing it using the <code>dput()</code> function.</p>
<p>For example you can use use the below code to provide the first 6 rows of the iris dataset.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dput</span>(<span class="fu">head</span>(iris))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>structure(list(Sepal.Length = c(5.1, 4.9, 4.7, 4.6, 5, 5.4), 
    Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9), Petal.Length = c(1.4, 
    1.4, 1.3, 1.5, 1.4, 1.7), Petal.Width = c(0.2, 0.2, 0.2, 
    0.2, 0.2, 0.4), Species = structure(c(1L, 1L, 1L, 1L, 1L, 
    1L), levels = c("setosa", "versicolor", "virginica"), class = "factor")), row.names = c(NA, 
6L), class = "data.frame")</code></pre>
</div>
</div>
<p>Try it yourself! Create a minimal dataset using the <code>dput()</code> function for the <code>penguins</code> dataset.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hint
</div>
</div>
<div class="callout-body-container callout-body">
<p>We want to be putting the <code>penguins</code> data to create a minimal dataset.</p>
</div>
</div>
<div id="qwebr-interactive-area-6" class="qwebr-interactive-area">
  <button class="btn btn-default qwebr-button qwebr-button-run" disabled="" type="button" id="qwebr-button-run-6">🟡 Loading
    webR...</button>
  <button class="btn btn-default qwebr-button qwebr-button-check" disabled="" type="button" id="qwebr-button-check-6">💡 Check answer</button>
  <button class="btn btn-default qwebr-button qwebr-button-solve" type="button" id="qwebr-button-solve-6">✅ Show solution</button>
  <button class="btn btn-default qwebr-button qwebr-button-reset" type="button" id="qwebr-button-reset-6">💥 Reset code</button>
  <div id="qwebr-console-area-6" class="qwebr-console-area">
    <div id="qwebr-editor-6" class="qwebr-editor"></div>
    <div id="qwebr-output-code-area-6" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-6" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-6");
  const checkButton = document.getElementById("qwebr-button-check-6");
  const solveButton = document.getElementById("qwebr-button-solve-6");
  const resetButton = document.getElementById("qwebr-button-reset-6");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-6");
  const editorDiv = document.getElementById("qwebr-editor-6");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-6");
  const webrCode = `
# Load the penguins dataset
library(palmerpenguins)
# Use dput() to create a minimal dataset
___
  `

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: webrCode,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           // TODO: Could be problematic for slide decks
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      fontSize: '17.5pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true  // Remove cursor indictor in right hand side scroll bar
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = true;
    });

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-6-result-${index + 1}" class="${className}">${qwebrEscapeHTMLCharacters(evt.data)}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "700px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-6-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run, .qwebr-button-check").forEach((btn) => {
      btn.disabled = false;
    });
    
    // Revert to the initial code cell state
    runButton.innerHTML = '<i class="fa-solid fa-play qwebr-icon-run-code"></i> <span>Run code</span>';
    checkButton.innerHTML = '💡 Check answer';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    // Emphasize the active code cell
    runButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Run code</span>';
    executeCode(editor.getValue());
  };
  
  checkButton.onclick = function () {
    // Emphasize the active code cell
    checkButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin qwebr-icon-status-spinner"></i> <span>Check answer</span>';
    executeCode(
`teachr_tests <- function(.code, .printed, .errored, .warned) {
  
c("Did you use dput() with head(penguins)?" =  !search_ast(.code, .expr = dput(head(penguins))))

}
check_answer(r"(` + editor.getValue() + `)")`
    );
  };
  
  solveButton.onclick = function () {
    editor.setValue(`
# Load the penguins dataset
library(palmerpenguins)
# Use dput() to create a minimal dataset
dput(head(penguins))
  `);
  };
  
  resetButton.onclick = function () {
    editor.setValue(webrCode);
  };
</script>
<p>You can then copy this generated code, and make it part of your example to create your example data.</p>
<p>Alternatively you can save this minimal dataset to a file, and attach the file in your question.</p>
<p>When you read that file in, make sure you avoid absolute paths to it. Not everyone has the same file structure as you, so they won’t be able to access your dataset if it is stored at <code>/home/learnr/Documents/My Job/project_2040/data/housing_prices.csv</code>. Instead provide a short relative oath, such as <code>housing_prices.csv</code> or <code>data/housing_prices.csv</code>. If you’re uploading files, it’s also nice to provide a zip that contains a R script of your minimal reproducible code, along with the data in the folders referenced by the script.</p>
<p>– potentially a multiple choice question here on relative paths? —</p>
</section>
<section id="create-minimal-reproducible-examples" class="level2">
<h2 class="anchored" data-anchor-id="create-minimal-reproducible-examples">Create minimal reproducible examples</h2>
<p>As part of a data analysis you probably write a lot of code. You need to read in the data, tidy it up, run some calculations and make some plots. When you run into an error, providing your entire analysis just makes it more time consuming for helpers to run your code and identify the source of the error.</p>
<p>A <em>minimal</em> reproducible example cuts out as much of the code as possible, keeping just a few essential lines for producing the error. If your error comes after the data cleaning, remove that code and start with a clean, minimal dataset.</p>
<p>If your code includes any randomisation, it’s a good idea to set the random seed using the <code>set.seed()</code> function. This ensures that each time the code is ran, the same random results are obtained.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Reproducing random results
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <code>set.seed()</code> function in R ensures reproducible results in code involving random values. It guarantees the same random values are produced each time you run the code, aiding in debugging and consistency. The number in the brackets can be any integer.</p>
</div>
</div>
<p>The process of cleaning up your code and reducing it down into a small example is another great exercise that often helps you identify the problem and fix it yourself.</p>
<p>Remember, you need to provide <strong>all code necessary</strong> to <strong>load in packages you use</strong>, <strong>read in data</strong> and <strong>run functions</strong> that cause the error.</p>
</section>
<section id="provide-session-information" class="level2">
<h2 class="anchored" data-anchor-id="provide-session-information">Provide session information</h2>
<p>Sometimes the error is specific to the version of R, or the packages you are using. To help others help you, you can provide the session information using the <code>sessioninfo::sessionInfo()</code> function. This will print out the version of R you are using, and the versions of the packages you have loaded, which makes it easier to fix some version, language or OS specific problems. A good reproducible example should come with this session information output.</p>
</section>
<section id="using-the-reprex-package-for-producing-examples" class="level2">
<h2 class="anchored" data-anchor-id="using-the-reprex-package-for-producing-examples">Using the <code>reprex</code> package for producing examples</h2>
<p>the <a href="https://reprex.tidyverse.org/"><code>reprex</code></a> package is a useful tool that can help you make a reproducible example. It can be used to run the code in your example in a clean environment, which is a good way to test if you’ve included everything necessary for others to reproduce the error. It’ll also copy a neatly formatted version of your example which will also display in your <strong>Viewer</strong> window and includes images and console output from the example as it runs on your computer. It can even include a collapsible summary of your session information.</p>
<p>To use <code>reprex</code>:</p>
<ol type="1">
<li>Install it from CRAN using <code>install.packages("reprex")</code>.</li>
<li>Once installed, load in the reprex package using <code>library(reprex)</code></li>
<li>You can use the <code>reprex()</code> function to create a reproducible example.</li>
</ol>
<p>You can also use the <code>reprex()</code> function in RStudio by selecting the code you want to include in the example, and clicking the “Reprex” button in the Addins menu.</p>
<div class="image-container">
    <img src="images/addin_reprex.png" width="260">
    <img src="images/popup_reprex.png" width="385">
</div>
<p>After clicking <code>Render reprex...</code> in the Addins menu, a new window will pop up with the reprex output (left image). As you’ve copied the example, you can use the ‘on the clipboard’ source. Choose a venue for where you’re planning to post the question, and tick ‘Append session info’. Finally, press <strong>Render</strong> to run the code and see if it’s reproducible.</p>
<p>View this <a href="https://www.youtube.com/watch?v=35suhGR53wQ">short clip</a> to see how to use the <code>reprex</code> package.</p>
</section>
</section>
<section id="asking-for-help-checklist" class="level1">
<h1>Asking for help checklist ☑️</h1>
<p>This is <strong>not an exhaustive check-list.</strong> What needs to be included and checked is very question specific, but this checklist should apply to most questions.</p>
<ul class="task-list">
<li><label><input type="checkbox">Is the problem <span class="highlight"><strong>clearly</strong></span> and <span class="highlight"><strong>succinctly described?</strong></span></label></li>
<li><label><input type="checkbox">Is the <span class="highlight"><strong>expected solution or behaviour</strong></span> outlined?</label></li>
<li><label><input type="checkbox">Has <span class="highlight"><strong>nobody asked this question</strong></span> before? (Search the web!)</label></li>
<li><label><input type="checkbox">Are you asking the <span class="highlight"><strong>right people</strong></span> at the <span class="highlight"><strong>right place?</strong></span></label></li>
<li><label><input type="checkbox">Have you added <span class="highlight"><strong>appropriate tags</strong></span> or <span class="highlight"><strong>keywords</strong></span> to reach the right experts?</label></li>
<li><label><input type="checkbox">Have you prepared your example using the <span class="highlight"><strong>reprex package</strong></span> to ensure the problem is easily reproduced on other computers?</label></li>
<li><label><input type="checkbox">Have you <span class="highlight"><strong>minimised your problem</strong></span> as much as possible, <span class="highlight"><strong>removing irrelevant packages, data and code</strong></span>?</label></li>
</ul>
<p><strong>If your questions involve a dataset</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Is the data supplied</label></li>
<li><label><input type="checkbox">If the data is big, <span class="highlight"><strong>could you cull your data further</strong></span> to communicate or reproduce the problem?</label></li>
</ul>


<script type="ojs-module-contents">
eyJjb250ZW50cyI6W119
</script>
<div id="exercise-loading-indicator" class="exercise-loading-indicator d-none d-flex align-items-center gap-2">
<div id="exercise-loading-status" class="d-flex gap-2">

</div>
<div class="spinner-grow spinner-grow-sm">

</div>
</div>
<script type="vfs-file">
W10=
</script>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/startr\.numbat\.space\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>