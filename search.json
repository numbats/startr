[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About StartR",
    "section": "",
    "text": "StartR is a website with materials to help you learn R and start using it to explore data. No prior experience in programming, statistics, or data is required to work through these materials. These materials were developed to prepare our students for our courses that expect some familiarity of R and data analysis."
  },
  {
    "objectID": "about.html#about-us",
    "href": "about.html#about-us",
    "title": "About StartR",
    "section": "About us",
    "text": "About us\n\n\n\n\n\nThis course is brought to you by the team at Monash University, Department of Econometrics and Business Statistics. You can find the full list of contributors in the link ‚ÄòContributors‚Äô at the footer of this site."
  },
  {
    "objectID": "modules/starter/debugging/index.html",
    "href": "modules/starter/debugging/index.html",
    "title": "5. Strategies for troubleshooting in R",
    "section": "",
    "text": "Code errors can be frustrating, but they‚Äôre actually trying to help by telling you what went wrong. Understanding how to read error messages, debug your code, and ask for help effectively will save you time in fixing these errors."
  },
  {
    "objectID": "modules/starter/debugging/index.html#understanding-errors-warnings-and-messages",
    "href": "modules/starter/debugging/index.html#understanding-errors-warnings-and-messages",
    "title": "5. Strategies for troubleshooting in R",
    "section": "Understanding errors, warnings, and messages",
    "text": "Understanding errors, warnings, and messages\nR uses three types of ‚Äòconditions‚Äô with different severity for issues with your code: errors, warnings, and messages. Regardless of severity, they should be read carefully as they provide useful information for improving your code.\n\nErrors üö®\nErrors stop your code from running, meaning that you won‚Äôt get any results. Errors indicate a problem with your code that must be fixed before execution can continue.\nTry to cause the sum() function to raise an error:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nEnsure that all elements you are attempting to sum are numeric. Mixing data types like characters and numbers will result in an error.\nsum(c(1, 3, \"apple\"))\n\n\n\n\nThere are many error messages that you might encounter, here‚Äôs a few common ones with some tips on how to fix them:\n\nError: object 'x' not found\nThe variable x does not exist in your environment. Have you typed the variable name correctly? Perhaps it actually doesn‚Äôt exist, and you need to create it by running your earlier code?\nError: cannot open the connection\nThe file path you‚Äôre trying to read does not exist or is incorrect. Carefully compare your file path with the location of the file on your computer.\nError: could not find function \"mutate\"\nThe function is from a package that has not been loaded with library().\nError in sample$x : object of type ‚Äòclosure‚Äô is not subsettable\nsample is a function (aka a ‚Äòclosure‚Äô), and not a dataset with an x variable.\nCheck the names of your variables, and try to use dataset names that don‚Äôt match function names (avoid data, sample, df, and dt).\nError in log(x, na.rm = TRUE) : unused argument (na.rm = TRUE)\nYou provided an argument that the function does not use. Check the help file for the function, and see which argument names are usable.\nError in log(...) : argument \"x\" is missing, with no default\nA required argument was not provided, for example log() without any numbers to log. Check the help file to understand how to provide the missing argument.\nError in library(package) : there is no package called 'package'\nThe package is not installed, install it with install.packages(\"package\").\n\n\n\n\n\n\n\nSilent errors\n\n\n\n\n\nErrors stopping your code can be frustrating, but they‚Äôve just saved you from something much worse: incorrect results. Situations where the code runs without complaints but produces incorrect results are known as silent errors.\nSilent errors are arguably the worst type of coding problem fix. They don‚Äôt give a helpful message about what went wrong and you might not even notice the problem until much later. Carefully check the results of your code to identify any unreasonable output that might be from a silent error.\n\n\n\n\n\nWarnings ‚ö†Ô∏è\nWarnings don‚Äôt stop execution but indicate something might be wrong. Your code runs, but the result may not be what you expect. After reading the warning, you should take a close look at your code and the output and make changes if the result isn‚Äôt right.\nTrigger a warning by using log() with negative values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe log() function accepts numbers greater than zero. If a negative number is used, it will produce a warning due to an invalid argument within its domain.\nresult &lt;- log(-1)  # This will produce a warning since log of negative numbers is undefined\n\n\n\n\nOther common warnings include:\n\nWarning: NAs introduced by coercion\nR tried to convert data to a different type (e.g., as.numeric(\"text\")) and failed, replacing invalid values with NA.\nWarning: number of items to replace is not a multiple of replacement length\nYou tried to assign values to a vector of a different length (e.g., x[1:5] &lt;- 1:3). This ‚Äòrecycles‚Äô values to get the replacement length (5), so x[1:5] will now contain c(1, 2, 3, 1, 2) rather than just 1:3.\nWarning: Removed X rows containing missing values (geom_point)\nggplot2 removed rows with NAs before plotting a the points, so be careful since any patterns in the missing values will not be evident in the plot.\nWarning: package ‚Äòdplyr' was built under R version X.Y.Z\nThe installed package was built for a different version of R than what you are currently using. This is usually ok, but it is safest to reinstall the problematic packages.\n\n\n\nMessages üí¨\nMessages are used to communicate important details about the code‚Äôs execution. They don‚Äôt necessarily indicate a problem with your code or results, but they should be read carefully to understand something important about your code or result.\nFor example, a message informs you of newly masked objects when you load a package like dplyr. Masked objects are usually functions (e.g.¬†lag()) which are replaced by functions of the same name from the package. You can explicitly use a function from a specific package with stats::lag() or dplyr::lag() to remove any ambiguity.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nLoading the dplyr package will produce a message regarding masking when function names overlap with those in base R.\nlibrary(dplyr)"
  },
  {
    "objectID": "modules/starter/debugging/index.html#troubleshooting-problems",
    "href": "modules/starter/debugging/index.html#troubleshooting-problems",
    "title": "5. Strategies for troubleshooting in R",
    "section": "Troubleshooting problems",
    "text": "Troubleshooting problems\n\nRead the message üìö\nThe first step is to carefully read the error message, it often contains clues into where and why the code didn‚Äôt run. With some time and experience, you‚Äôll begin to identify these errors and fix your code quickly based on the message alone!\nSome of the most common (and most confusing) error messages were described earlier, but if you‚Äôre having trouble understanding the message then you might need to search for more information.\n\n\nSearch the message üîé\nError messages can be confusing, and even after carefully reading the message it may be difficult to ascertain what the problem is.\nChances are you‚Äôre not the first person to encounter this problem and there‚Äôs a well explained solution waiting for you on the internet - you just need to find it. Just copy the error exactly, add some relevant contextual keywords like ‚ÄúR‚Äù and search!\nWith some luck, you‚Äôll be met with a series of StackOverflow threads, blog posts and other websites explaining the solution to the exact problem you‚Äôre facing.\n\n\n\n\n\n\nTips for searching errors online\n\n\n\n\n\n\nAdd double quotes around the error message. This searches for those exact words in that exact order.\nOnly search generic parts of the error message (don‚Äôt include specifics of your code or variable names)\nAdd keywords relating to the problem, like the language ‚ÄòR‚Äô, the package ‚Äòdplyr‚Äô, and the context ‚Äòjoining data‚Äô.\nIf you‚Äôre looking for solutions on a specific website, add site:&lt;domain&gt; to the search. For example, site:stackoverflow.com.\n\n\n\n\n\n\nDivide and conquer üí™\nIf you understand the message, but have no idea where the problem stems from - try running smaller sections of your code to see if that small section causes the error. Once you identify the small section of code causing the error, it should be slightly easier to find the issue in your code.\n\n\n\n\n\n\nPoor code readability makes debugging harder\n\n\n\n\n\nIf you frequently struggle to locate errors, your code style might be part of the problem.\nBreaking your code into small modular chunks instead of cramming everything into one line makes debugging easier. For best practices on writing clean, maintainable R code, check out Jenny Bryan‚Äôs UseR! 2018 talk, Code Smells and Feels.\n\n\n\n\n\nRead the documentation üìÑ\nR‚Äôs built-in documentation can help you understand how functions are supposed to be used.\nUse ?function_name or help(function_name) to access a function‚Äôs help page, which includes descriptions, usage examples, and default values. You might also find reading the package vignettes with vignette(package=\"dplyr\") useful, they offer guided introductions into how to use the package.\n\n\nTurn it off and on again üîÑ\nThe age old classic (but sometimes it really does work!).\nIn R, you don‚Äôt necessarily need to restart your whole computer, but instead you can try restarting RStudio, or your R session. Usually I would restart R, which can be done in RStudio in two ways:\n\n‚ÄòSession‚Äô on the top menu bar, then ‚ÄòRestart R‚Äô\nCtrl-Shift-F10Ctrl-Shift-F10 (Windows) or Cmd-Shift-F10Cmd-Shift-F10 (Mac)\n\nThis can fix your problem by resetting your environment to a clean state. Re-running your code without extra unused packages loaded or old variables in the environment might just work!"
  },
  {
    "objectID": "modules/starter/debugging/index.html#asking-for-help",
    "href": "modules/starter/debugging/index.html#asking-for-help",
    "title": "5. Strategies for troubleshooting in R",
    "section": "Asking for help",
    "text": "Asking for help\nOnce you‚Äôve carefully read the error, searched the web, and tried everything else you can think of, it‚Äôs time to ask others for help.\n\nAsking good questions\nTo get useful help, it is important that you ask a good question. Consider answering these two equivalent questions, which is easier to understand?\n\n\n\n\n\n\n‚ùå Bad question\n\n\n\nurgent help needed with assignment error\nMy code doesn‚Äôt work. Please help i need it working for my assignment asap!\ndata &lt;- read.csv(‚ÄúC://Users/James/Downloads/project-a9j-2020a/files/survey_data.csv‚Äù) data %&gt;% filter(y == ‚ÄúA‚Äù) %&gt;% ggplot(aes(y = y, x = temperature)) + geom_line()\n\n\n\n\n\n\n\n\n‚úÖ Good question\n\n\n\nError with dplyr filter(): ‚Äúobject not found‚Äù\nI‚Äôm trying to filter a dataset in dplyr, but I‚Äôm getting an error that I don‚Äôt understand. Here‚Äôs my code and error message:\nsurvey &lt;- data.frame(x = c(1, 2, 3), y = c(\"A\", \"B\", \"C\"))\nsurvey %&gt;% filter(y == \"A\")\nError: Error in filter(y == \"A\") : object 'y' not found\nI expected it to return rows where y is \"A\". How should I fix this?\n\n\nWriting a good question will help you and others understand your problem, and you might even find the solution in the process of writing it! Here‚Äôs some tips for writing good questions:\n\nBe clear and concise\nExplain what you‚Äôre trying to do and what isn‚Äôt working.\nExplain what you expected\nDescribe the output or behaviour you were hoping for.\n\nProvide a minimal reproducible example (reprex)\nShare a small, self-contained snippet of code that reproduces the issue. The {reprex} package will help you do this.\nStyle your code\nUse a code style with proper indentation and spacing to make it easy to read.\nInclude the full error message\nCopy and paste the exact error instead of summarising it.\n\nShow what you‚Äôve already tried\nBriefly mention other solutions you‚Äôve tried to avoid duplicate suggestions.\n\n\n\nCreating minimal reproducible examples\nA minimal reproducible example (MRE) is essential for effectively communicating problems with code. The process of creating a MRE might also help you resolve the problem yourself!\nThe guiding principles of creating a minimal reproducible example are:\n\nMinimal\nMinimising code and data makes it easier for others to find the problem and offer a solution. Isolating the problem down to just a few lines of code or rows of data can help you (and those helping you) understand exactly where the problem is caused.\n\nRemove unnecessary code\nInclude as little code as possible to show the problem.\nUse small datasets\nPrefer built-in datasets or create/sample small example datasets.\nAvoid external dependencies\nRemove any unused packages or files that are irrelevant to the problem.\n\nIn the bad/good code example, the good code is more minimal because it removes the irrelevant ggplot2 code.\n\n\nReproducible\nReproducible code includes all elements needed recreate the problem on a different computer, including:\n\nRequired packages\nIf external packages are needed, include loading the packages in your MRE.\nUsed datasets\nIf you can‚Äôt use built-in datasets, then ideally the minimal dataset is created with code without separate data files. You can create a dataset directly with data.frame(), or convert any existing R object into code with dput(). Try using dput() with the letters vector.\nSet random seeds\nIf your problem includes randomisation (e.g.¬†sample(), or random samples from distributions), you should also include set.seed() at the top of your MRE with a seed that reproduces the problem.\n\nThe good code example above is more reproducible because it directly embeds the dataset into the code. In the process of making the MRE (specifically thinking about the required packages for the code) might result in the discovery that this problem is resulting from not loading dplyr with library(dplyr)!\n\n\n\n\n\n\nSession information\n\n\n\n\n\nSometimes the error is specific to your system, and isn‚Äôt easily reproduced on other computers. Some issues can be specific to other things about your system such as your operating system, system language/locale, R version, or R package versions.\nTo include useful information about your system, include sessioninfo::session_info() at the end of your example. If you‚Äôre using {reprex} to create your MRE you can use repex(session_info = TRUE).\n\n\n\n\n\nExample\nThe minimal and reproducible code you write should be an example of the problem you are facing!\n\nClearly state the issue\nExplain what you expect versus what happens.\nEnsure clarity\nAdd code comments to highlight your intention and the problem.\n\nThe good code example clearly describes the goal and unexpected result.\n\n\n\n\n\n\nCreating MREs with the {reprex} package\n\n\n\n\n\nThe {reprex} package helps you share reproducible examples by running the example code in a clean environment and then copying a neatly formatted version of your code and its results (including tables, figures, and more).\nTo create a reprex, simply:\n\nCopy the example code that you‚Äôve made minimal and reproducible,\nRun reprex::reprex(), or click `Render reprex... in the Addins menu and follow the prompts,\nWhen the results are ready, you‚Äôll find a preview of the MRE pop-up in the Viewer tab of RStudio (and the markdown code for sharing it copied to your clipboard),\nPaste the results into the help forum of your choice (some useful places are listed below).\n\nView this short clip for a guided walkthrough of using the reprex package by it‚Äôs creator!\n\n\n\n\n\n\nWhere to ask for help\n\n\n\n\n\n\n\nClass Discussion Forum (e.g.¬†Moodle)\nIf you‚Äôre preparing for your Monash University course, a good place to ask for help is the discussion forum on Moodle. You can also seek assistance from your lecturers and tutors.\n\n\nAsk an LLM\nThere are many large language models (LLMs) that can help you write and debug code. However, AI tools should be used with caution. While it can assist in troubleshooting errors, it may not always provide the best solution. You should still try to understand what the code is doing and why it‚Äôs causing an error to avoid using code from AI which may be producing inaccurate results (despite running without error).\n\n\nConsultations\nAsk your lecturers and tutors for help during consultation sessions, which are available for any content-related difficulties, including debugging code.\n\nPrepare a small demonstration of your error beforehand to make the session more effective.\nThe benefit of these sessions is that we can guide you closer to the solution until you figure it out yourself.\nDon‚Äôt be disheartened if your error, which you‚Äôve struggled with for hours, is solved in minutes ‚Äî we‚Äôve had plenty of practice (also being stuck for hours) troubleshooting these errors.\n\n\n\nStack Overflow\nThis is a platform where you can search for solutions and ask for help. It is likely that people have already asked similar questions related to your error and you can try the solutions provided by others under the question. Thoroughly search for similar questions already asked on the website before asking for help with your problem.\n\n\nPosit Community\nThis is a community channel for RStudio users. Similar to Stack Overflow, you can ask questions and also find solutions.\n\n\nGitHub\nIf you‚Äôve thoroughly investigated your error and believe the issue lies in the package rather than your code, you can contact the package‚Äôs developer. Most R packages are maintained on GitHub, and developers typically prefer problems with their packages reported in the GitHub repository‚Äôs issues‚Äîjust make sure that a similar issue hasn‚Äôt already been reported!\n\n\n\n\n\n\n\n\n\nHelp and Learn\n\n\n\n\n\nAnswering questions on the forum can help consolidate your understanding and prepare you for asking and answering questions in other forums such as Stack Overflow."
  },
  {
    "objectID": "modules/starter/project-structure/index.html",
    "href": "modules/starter/project-structure/index.html",
    "title": "4. Projects and paths",
    "section": "",
    "text": "Good project organisation is essential for collaboration, transparency, and reproducibility in any data analysis project. A well organised project sets a strong foundation for reliable data analysis, ultimately saving you time and reducing the risk of errors.\nThis module introduces practical strategies to organise your workflow and files. You will learn how to create and use R Projects, understand relative and absolute file paths, and structure your work for clarity and reproducibility."
  },
  {
    "objectID": "modules/starter/project-structure/index.html#sec-projects",
    "href": "modules/starter/project-structure/index.html#sec-projects",
    "title": "4. Projects and paths",
    "section": "R Projects",
    "text": "R Projects\nR Projects are an RStudio feature that can help you organise all files related to a single project folder and access them in a project specific workspace.\n\n\n\nArtwork by @allison_horst.\nUsing an R Project in RStudio helps with:\n\nAutomatic working directory: When you open an R Project, RStudio automatically sets the working directory location to the project‚Äôs folder. The working directory is the folder relative file paths are built from (more details later).\nProject settings: The .Rproj file created when you make an R Project stores project-specific settings and keyboard shortcuts (e.g., git, packages, or documents). These settings are automatically loaded when you open the project in RStudio.\nWorkspace restoration: When you reopen an R Project, Rstudio will reload your workspace (scripts, unsaved changes and history) exactly how you left it.\nFolder structure: R projects make it easy to access related files in the project folder with relative paths, making your analysis easier to share with others.\n\n\n\n\n\n\n\nCreate an R project\n\nClick the project drop-down in the top-right corner. Then click on the ‚ÄúNew Project‚Ä¶‚Äù.\n\n\n\nIt will show you three options.\n\nNew Directory: Start from scratch with a new empty folder for your project.\nExisting Directory: If you‚Äôre already started some work without a project, convert that folder into a project.\nVersion Control: If your work already exists elsewhere as a git or svn repository (such as GitHub), this will download the work and create a project for it.\n\nFor your very first R project, let‚Äôs start by selecting ‚ÄúNew Directory‚Äù.\n\n\n\nThere are many different types of R projects that you can create. These various project types come bundled with starter code and settings (for shortcuts and build options). A standard project (without any boilerplate or settings) is suitable most projects - so simply select ‚ÄúNew Project‚Äù for an empty folder.\n\n\n\nGive your project (and the folder containing it) a name using the ‚ÄúDirectory name:‚Äù field. You can also choose where the project will exist on your computer by clicking on the ‚ÄúBrowse‚Ä¶‚Äù button. If you do not choose, it will be in your home folder (/home/&lt;username&gt; on macOS, and C:/Users/&lt;username&gt; on Windows). You can leave the rest (git and renv) unchecked for now.\n\n\n\nClick ‚ÄúCreate Project‚Äù.\n\n\n\n\n\n\n\n\nProject created!\n\n\n\nYou have now successfully created the R project! Verify this by checking:\n\nThe project name in the top right project dropdown\nThe current working directory (getwd()) is the project folder\nThe files pane shows the content of your project folder\n\n\n\n\n\nUsing R projects\nThere are multiple ways to open an R Project in RStudio:\n\nRStudio Project Selector:\nUse the project selector dropdown in the top right corner to quicky switch between recent projects. \nOpening the .Rproj File:\nOpen the project‚Äôs .Rproj file from your file explorer. \n\nAny work you do while in this project will be restored when you next open the project (even unsaved files, but please don‚Äôt rely on this and save your work!).\nYou can close the project by simply closing RStudio (or via Project selector (top-right) ‚Üí Close Project to keep RStudio open).\nWhen you close your project you might be prompted to save your ‚Äòworkspace image‚Äô, to which we recommend you select Don‚Äôt Save.\n\n\n\n\n\n\n\nSaving the workspace image? No!\n\n\n\n\n\nWhile you should always save your work, it is best for reproducibility to not save your workspace image. Saving the workspace means next time you open the project, R Studio will also reload your last R session, along all of the variables and functions you previously created. While this seems convenient, it is better to explicitly load data and scripts each time you open a project to ensure that your analysis results can be re-run by anyone, including your future self.\n\n\nYou can prevent the popup messages by going to Tools ‚Üí Global Options. Then select General on the side-bar and change ‚ÄúSave workspace to .RData on exit‚Äù to ‚ÄúNever‚Äù.\n\n\n\n\n\n\nProject organisation\n\n\n\nArtwork by @allison_horst.\nWhile an R Project helps you quickly switch between projects, it is up to you to organise your files into suitable subfolders within the project folder. By structuring your files effectively, you can reduce the risk of losing important data, simplify the code for accessing your data, and make it easier to locate each script.\n\n\n\n\n\n\nFile folders\nA clear and consistent folder structure starts with sensible folder names. Here‚Äôs an example of a typical R Project directory structure:\nmy-awesome-project/\n‚îú‚îÄ‚îÄ data-raw/                   # Raw / unprocessed data files\n‚îÇ   ‚îú‚îÄ‚îÄ survey_results_2024.csv\n‚îÇ   ‚îú‚îÄ‚îÄ population_data.xlsx\n‚îú‚îÄ‚îÄ data/                       # Clean / processed data files\n‚îÇ   ‚îú‚îÄ‚îÄ survey_cleaned_2024.csv\n‚îÇ   ‚îú‚îÄ‚îÄ population_summary.csv\n‚îú‚îÄ‚îÄ R/                          # R scripts\n‚îÇ   ‚îú‚îÄ‚îÄ data_cleaning.R\n‚îÇ   ‚îú‚îÄ‚îÄ exploratory_analysis.R\n‚îÇ   ‚îî‚îÄ‚îÄ model_fitting.R\n‚îú‚îÄ‚îÄ outputs/                    # Results, figures, tables, and other outputs\n‚îÇ   ‚îú‚îÄ‚îÄ figures/                # Graphs and charts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ age_distribution_plot.png\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ time_series_trends.jpeg\n‚îÇ   ‚îî‚îÄ‚îÄ tables/                 # Data tables and results\n‚îÇ       ‚îú‚îÄ‚îÄ regression_summary.csv\n‚îú‚îÄ‚îÄ README.md                   # Project description and instructions\n‚îî‚îÄ‚îÄ my-awesome-project.Rproj    # R Project file\nThis structure is suitable for most simple data analysis projects. We recommend you try to organise a few projects with this template before making modifications based on your personal preferences and project specific needs.\n\n\n\n\n\n\nExpand For Recommended Folder Uses\n\n\n\n\n\n\ndata-raw/: This folder holds all original data files related to the project. Keeping raw and processed data separate ensures transparency and helps maintain data integrity.\ndata/: Save your tidy, clean and otherwise processed data here. This allows you to quickly read in analysis-ready data without needing to re-run your data cleaning script.\nR/: Store all your R scripts here, we recommend the folder name ‚ÄúR‚Äù (to match the structure of an R package). More language-agnostic projects might use a ‚Äúsrc‚Äù, ‚Äúscripts‚Äù, or ‚Äúcode‚Äù folder. It‚Äôs a good practice to separate scripts into different categories depending on their function (e.g., data cleaning, analysis, modelling).\noutputs/: This folder stores the outputs of your analysis, such as figures, tables, or models. You can have subfolders like figures/ and tables/ to separate the different types of results. This makes it easier to find specific outputs and ensures that your working directory isn‚Äôt cluttered with unnecessary files.\nREADME.md: A README file is essential for documenting the purpose of the project, how to run the analysis, and any specific instructions for collaborators. This file helps others (and yourself, in the future) understand the project structure, dependencies, and key steps involved.\nmy-awesome-project.Rproj: This is the R Project file, which we created earlier. Projects help maintain your project‚Äôs workspace, settings, and set the working directory. It should always be kept at the root of the project folder.\n\n\n\n\n\n\n\nPortable and reproducible projects\nOne of the key principles of maintaining an organised and reproducible workflow is to keep all project-related files within the project folder. This approach ensures that your project has:\n\nReproducibility: By keeping everything in one place, you ensure that your code can easily locate all the necessary files (data, scripts, outputs) using relative paths. This makes your analysis reproducible for anyone who accesses the project.\nPortability: A self-contained project is portable, meaning you can move it to another computer, share it with collaborators, or distribute it with version control platforms (e.g.¬†GitHub) without breaking any links or dependencies.\nOrganisation: Storing all files in one structured location helps avoid confusion and ensures you can quickly locate the resources you need.\n\n\n\n\n\n\n\n\nR packages not included\n\n\n\n\n\nR projects usually include everything except the R packages it depends on, which are instead usually found in the system‚Äôs global R environment.\nThis can cause reproducibility issues if the project is used on a system where some packages are missing, incompatible, or at different versions with different functionality. To address this, you can use the renv package, which bundles and manages package versions locally within the project folder. This ensures that your analysis always uses the correct versions of dependencies. \n\n\n\n\n\nCheck your understanding\nWhat is the main benefit of using an RStudio Project?\n\n\n\n\n\n\n\n\n\nHow can you open an RStudio Project?\n\n\n\n\n\n\n\n\n\nWhat happens to the working directory when you open an RStudio Project?\n\n\n\n\n\n\n\n\n\nWhich of the following files is typically included in an RStudio Project?\n\n\n\n\n\n\n\n\n\nWhich of the following is NOT true about RStudio Projects?\n\n\n\n\n\n\n\n\n\nWhat should you avoid when closing an RStudio Project?"
  },
  {
    "objectID": "modules/starter/project-structure/index.html#sec-path",
    "href": "modules/starter/project-structure/index.html#sec-path",
    "title": "4. Projects and paths",
    "section": "File Paths",
    "text": "File Paths\nWhen working with files in R, understanding and using file paths correctly is essential to ensure your scripts run seamlessly, whether on your computer or someone else‚Äôs.\n\n\nFile paths can be specified in two main ways: absolute paths and relative paths. Both approaches work to locate files, but they behave very differently when running your code on other computers. Appropriately specified file paths ensure that your projects will be portable to other people‚Äôs computers by enabling others to execute your analysis workflow without editing your scripts.\n\nAbsolute paths\nAn absolute path specifies the full location of a file or folder on your system starting from the root directory (e.g., C:/ on Windows or / on macOS/Linux).\nExample:\n# Windows\ndata &lt;- read.csv(\"C:/Users/Admin/Documents/my-awesome-project/data/survey_data.csv\")\n\n# macOS/Linux\ndata &lt;- read.csv(\"/home/Admin/Documents/my-awesome-project/data/survey_data.csv\")\nNotice how the file path differs between operating systems? This is bad for reproducibility.\n\n\n\n\n\n\nAbsolute paths are NOT portable!\n\n\n\n\n\nWhile absolute paths work on your computer, they are not portable because:\n\nThey depend on the exact file structure of your system.\nIf you share your project with others, their computer systems may not have the same directory structure.\nMoving your project to a new location can break the paths.\n\nFor these reasons, using absolute paths is strongly discouraged.\n\n\n\n\n\nRelative paths\nA relative path specifies the location of a file or folder relative to the current working directory. If you work within an [R Project]((#sec-projects), the current working directory is automatically set to the project folder, making relative paths the most reliable and portable option.\nExample:\n# Windows/macOS/Linux\ndata &lt;- read.csv(\"./data/survey_data.csv\")\nIn this example:\n\n./ refers to the current working directory. It is optional.\n./data/ navigates to the data/ subfolder within the project folder.\n\nRelative paths ensure that your scripts work regardless of where the project folder is located, as long as the folder structure remains consistent. This makes them ideal for reproducible analysis. üéâ\n\n\n\n\n\n\nFinding files\n\n\n\n\n\nWhen specifying file paths in R, you can use tab completion to quickly find and insert file paths. Inside quotation marks (‚Äú‚Äú), start typing the folder or file name and press the TabTab key.\nRStudio will then show a list of matching files and folders, making it easier to navigate your project, find files and avoid typos.\nVideo\n\n\n\n\nWorking directories\nThe working directory in an R session is the folder from which R looks for files specified using relative paths. The working directory is almost always your project folder.\nYou can check your current working directory with the getwd() function.\n\n\n\n\n\n\n\n\n\n\n\nThis function returns the absolute path of the current working directory.\nYou can (but shouldn‚Äôt) change your working directory with setwd(). Instead, we strongly recommend using R Projects and relative paths from the project folder.\n\n\n\n\n\n\nWorking directory in R Markdown and Quarto\n\n\n\n\n\nWhen running R Markdown or Quarto documents, the working directory is instead the location of the document. You can think of these documents as being their own mini-projects, where files paths to images and data are relative to the document.\nIf your document is in a sub-folder of an R project the relative paths can be confusing. R scripts will use the project folder, while your R documents will use the document folder!\n\n\n\n\n\n\n\n\nProject paths\nAnother type of relative path is a project path, which specifies the location of files relative to the project folder (rather than the working directory). This can be useful since the project paths will work even if the working directory in R changes (e.g.¬†when using code in R Markdown or Quarto documents).\n\n\n\nArtwork by @allison_horst.\nThe here package helps you create file paths relative to the project folder, ensuring that your scripts and analyses are portable and reproducible across different systems. The here() function automatically detects the project folder based on the location of your .Rproj file (or other indicators, like a README.md or .git folder).\nExample:\n# Windows/macOS/Linux\ndata &lt;- read.csv(here::here(\"data/survey_data.csv\"))\nIn this example:\n\nhere::here() refers to the the project folder.\ndata/survey_data.csv is the path to the dataset from the project folder.\n\n\n\n\n\n\n\nProject portability\n\n\n\n\n\nSince project paths are relative to the project folder, you will need to share the entire project for your code to be reproducible by others. Without the .Rproj file (or other project indicator), the here::here() package won‚Äôt know which folder is your project folder.\n\n\n\n\n\n\nExternal paths\nExternal paths refer to file locations external to the computer you are using but accessible over a network connection. External paths are specified with a URL (Uniform Resource Locator).\nExample:\n# Windows/macOS/Linux\ndata &lt;- read.csv(\"https://learnr.numbat.space/data/survey_results.csv\")\nA URL consists of several parts:\n\nProtocol (https://): The communication method used to access the resource. Most often this will be http or https (Hypertext Transfer Protocol Secure, the protocol for websites). Other protocols that are commonly used include ftp (File Transfer Protocol), or s3 (Simply Storage Service).\nAddress / Location (learnr.numbat.space): The network address of the server hosting the resource. In this case, learnr.numbat.space is the address, identifying the specific server to connect to.\n\nPath (/data/survey_results.csv): The absolute path of the file or resource on the server.\nOther Information: Sometimes additional details are needed to connect to the external server, commonly this is:\n\nA port number like :8080 specifies a network port (https://learnr.numbat.space:8080/...).\n\nCredentials like username:password@ can provide login information (https://user:pass@learnr.numbat.space/...).\n\n\n\n\n\n\n\n\nUsing external paths\n\n\n\n\n\nMany R functions allow you to directly use web URLs for accessing data, for example read.csv() shown earlier. If the function you want doesn‚Äôt support external file paths, you can download the files with download.file().\ndownload.file(\"https://learnr.numbat.space/data/survey_results.csv\", destfile = \"data/survey_results.csv\")\ndata &lt;- read.csv(\"data/survey_results.csv\")\n\n\n\n\n\n\nCheck your understanding\nWhich of the following is an example of an absolute path?\n\n\n\n\n\n\n\n\n\nWhy should you avoid using absolute paths in R scripts?\n\n\n\n\n\n\n\n\n\nWhat does the {here} package do?\n\n\n\n\n\n\n\n\n\nWhich of the following is NOT true about relative paths?\n\n\n\n\n\n\n\n\n\nWhich part of the URL specifies the communication method for the external resource?"
  },
  {
    "objectID": "modules/statistics/linear-regression/index.html",
    "href": "modules/statistics/linear-regression/index.html",
    "title": "1. Linear regression",
    "section": "",
    "text": "Regression modelling helps us understand relationships between variables and make predictions. Regression allows us to quantify these relationships between two or more variables to make informed decisions based on data. The lm() function in R allows us to estimate linear regression models using a model formula."
  },
  {
    "objectID": "modules/statistics/linear-regression/index.html#simple-linear-regression",
    "href": "modules/statistics/linear-regression/index.html#simple-linear-regression",
    "title": "1. Linear regression",
    "section": "Simple linear regression",
    "text": "Simple linear regression\nA simple linear regression models the relationship between one predictor (X) and one response (Y).\nMathematically, general formula is:\n\\[\\mathbf{Y} = \\beta_0\\mathbf{1} + \\beta_1 \\mathbf{X} + \\boldsymbol{\\varepsilon}\\]\nwhere:\n\n\\(\\mathbf{Y}\\) is the dependent variable (what is being predicted),\n\\(\\mathbf{1}\\) is a vector containing 1 (for the intercept),\n\\(\\mathbf{X}\\) is the independent variable (how it is predicted),\n\\(\\beta_0\\) (intercept) and \\(\\beta_1\\) (slope) are model parameters,\n\\(\\boldsymbol{\\varepsilon}\\) represents random error (assumed \\(\\varepsilon_i \\overset{iid}{\\sim} N(0,1)\\)).\n\nProgrammatically, the R model formula is:\nlm(Y ~ 1 + X, data = data)\nwhere:\n\nY is the name of the dependent variable from data,\n1 indicates to include an intercept,\nX is the name of the independent variable from data,\ndata is the name of the dataset being modelled.\n\n\nExample: Predicting penguin weight\nLet‚Äôs predict the weight of adult foraging penguins nearby Antarctica‚Äôs Palmer Station. This dataset is included in the palmerpenguins package.\nThe weight of each penguin is recorded in the body_mass_g column (our dependent variable), and we will use the length of their bill (from the bill_length_mm column) to predict it. Our hypothesis could be that a larger bill allows a penguin to eat more fish!\n\nlibrary(palmerpenguins)\n# Fit simple linear regression model\nlm(body_mass_g ~ bill_length_mm, data = penguins)\n\n\nCall:\nlm(formula = body_mass_g ~ bill_length_mm, data = penguins)\n\nCoefficients:\n   (Intercept)  bill_length_mm  \n        362.31           87.42  \n\n\nThe coefficient for bill_length_mm (\\(\\beta_1 \\approx 87.42\\)) indicates that for each additional millimetre in bill length, the penguin‚Äôs body mass increases by roughly 87.42 grams on average.\nTo evaluate the significance of this relationship, we can look at the model in more detail using summary().\n\n# Fit simple linear regression model\nfit &lt;- lm(body_mass_g ~ bill_length_mm, data = penguins)\n\n# View model summary\nsummary(fit)\n\n\nCall:\nlm(formula = body_mass_g ~ bill_length_mm, data = penguins)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1762.08  -446.98    32.59   462.31  1636.86 \n\nCoefficients:\n               Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)     362.307    283.345   1.279    0.202    \nbill_length_mm   87.415      6.402  13.654   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 645.4 on 340 degrees of freedom\n  (2 observations deleted due to missingness)\nMultiple R-squared:  0.3542,    Adjusted R-squared:  0.3523 \nF-statistic: 186.4 on 1 and 340 DF,  p-value: &lt; 2.2e-16\n\n\nThe summary() output shows that the bill_length_mm coefficient has a p-value of \\(&lt; 2e^{-16}\\) (nearly 0), which is significant at a 5% level (since it is less than 0.05). This analysis and interpretation isn‚Äôt reliable, since there are many statistical considerations which have not yet been satisfied.\n\n\n\n\n\n\nInterpret with caution\n\n\n\n\n\nWhile the model provides useful insights, it should be interpreted with caution. Making accurate interpretations from a model requires thorough investigation of the model and data. A deeper understanding of the model‚Äôs capabilities and assumptions is beyond this lesson.\nWhile the model suggests a positive relationship between bill length and body mass, there are several important caveats and assumptions to consider:\n\nAssumed Linearity\nThe model assumes a linear relationship between bill length and body mass. If the true relationship is curved or more complex, a simple linear regression may not be appropriate.\nCausation vs.¬†Correlation\nThe model does not prove that bill length causes changes in body mass‚Äîit only identifies an association. Other factors (e.g., diet, age, species differences) may influence both variables.\nOmitted Variable Bias\nThe model only includes bill length as a predictor. Other important predictors like flipper length, species, or sex might influence body mass. Ignoring these could lead to misleading results.\nExtrapolation Risk\nPredictions should only be made within the range of observed bill lengths in the dataset. For example, predicting body mass for a penguin with an extremely small or large bill (outside the dataset‚Äôs range) could lead to unreliable estimates.\nResidual assumptions\nThe model assumes that residuals (errors) are \\(\\varepsilon_i \\overset{iid}{\\sim} N(0,1)\\), and this should be assumption should be tested with residual diagnostics. The iid means:\n\nIndependent (and)\nThe weight of one penguin does not affect another\nIdentically\nAll residuals have a:\n\nmean of 0 (needed for unbiased predictions)\nconstant variance (needed for accurate prediction intervals)\n\nDistributed\nThe residuals are normally distributed (needed for valid hypothesis testing)\n\n\n\n\n\nTry estimating a simple linear regression model with a different predictor from the Palmer penguins dataset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nChoose another variable from the penguins dataset, such as bill_depth_mm, flipper_length_mm, or species for building the model.\nfit &lt;- lm(body_mass_g ~ bill_depth_mm, data = penguins)\nsummary(fit)"
  },
  {
    "objectID": "modules/statistics/linear-regression/index.html#multiple-linear-regression",
    "href": "modules/statistics/linear-regression/index.html#multiple-linear-regression",
    "title": "1. Linear regression",
    "section": "Multiple linear regression",
    "text": "Multiple linear regression\nA multiple linear regression extends simple linear regression by including multiple predictors (X‚ÇÅ, X‚ÇÇ, ..., X‚Çô) to explain variations in a response variable (Y). This helps account for additional sources of variation and can reduce omitted variable bias, which occurs when an important predictor is left out, potentially leading to misleading estimates.\nMathematically, the general formula is:\n\\[\\mathbf{Y} = \\beta_0\\mathbf{1} + \\beta_1 \\mathbf{X_1} + \\beta_2 \\mathbf{X_2} + \\dots + \\beta_n \\mathbf{X_n} + \\boldsymbol{\\varepsilon}\\]\nwhere:\n\n\\(\\mathbf{X_1}, \\mathbf{X_2}, \\dots, \\mathbf{X_n}\\) are independent variables (predictors),\n\\(\\beta_1, \\beta_2, \\dots, \\beta_n\\) are their respective coefficients,\n\\(\\beta_0\\) is the intercept,\n\\(\\boldsymbol{\\varepsilon}\\) represents random error.\n\nProgrammatically, the R model formula is:\nlm(Y ~ 1 + X1 + X2 + X3 + ..., data = data)\nwhere:\n\nY is the name of the dependent variable from data,\n1 indicates to include an intercept,\nX1, X2, X3, ‚Ä¶ are the names of the independent variables from data,\ndata is the name of the dataset being modelled.\n\n\nExample: Predicting penguin weight with multiple predictors\nInstead of just using bill length, we now incorporate flipper length as an additional predictor. Our hypothesis is that both bill size and flipper size contribute to the body mass of a penguin (perhaps longer flippers helps a penguin swim faster to catch more fish)!\n\n# Fit multiple linear regression model\nfit_multi &lt;- lm(body_mass_g ~ bill_length_mm + flipper_length_mm, data = penguins)\n\n# View model summary\nsummary(fit_multi)\n\n\nCall:\nlm(formula = body_mass_g ~ bill_length_mm + flipper_length_mm, \n    data = penguins)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1090.5  -285.7   -32.1   244.2  1287.5 \n\nCoefficients:\n                   Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       -5736.897    307.959 -18.629   &lt;2e-16 ***\nbill_length_mm        6.047      5.180   1.168    0.244    \nflipper_length_mm    48.145      2.011  23.939   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 394.1 on 339 degrees of freedom\n  (2 observations deleted due to missingness)\nMultiple R-squared:   0.76, Adjusted R-squared:  0.7585 \nF-statistic: 536.6 on 2 and 339 DF,  p-value: &lt; 2.2e-16\n\n\nEach coefficient can be interpretted similarly to simple linear regression.\n\nThe coefficient for bill_length_mm (\\(\\beta_1 \\approx 6.05\\)) indicates that for each additional millimetre in bill length, the penguin‚Äôs body mass increases by roughly 6.05 grams on average, holding flipper length constant. However, the p-value (0.244) suggests this effect is not statistically significant at a 5% level.\nThe coefficient for flipper_length_mm (\\(\\beta_2 \\approx 48.15\\)) indicates that for each additional millimetre in flipper length, the penguin‚Äôs body mass increases by roughly 48.15 grams on average, holding bill length constant. This effect is highly significant (p &lt; 0.001).\n\nNotice that when including the flipper length in the model, the coefficient for bill length (\\(\\beta_1\\)) becomes much smaller and is no longer statistically significant (p = 0.244). This suggests that flipper length may account for much of the variation in body mass that was previously attributed to bill length in a simple linear regression. In other words, bill length‚Äôs effect on body mass may have been overstated in the simpler model due to omitted variable bias, and flipper length appears to be a stronger predictor of body mass.\nNow add the bill depth to the model and see how it changes the model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nInclude the specified numerical predictors: bill_length_mm, bill_depth_mm, and flipper_length_mm to build the model.\nfit &lt;- lm(body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm, data = penguins)\nsummary(fit)"
  },
  {
    "objectID": "modules/statistics/linear-regression/index.html#categorical-predictors-dummy-variables",
    "href": "modules/statistics/linear-regression/index.html#categorical-predictors-dummy-variables",
    "title": "1. Linear regression",
    "section": "Categorical predictors (dummy variables)",
    "text": "Categorical predictors (dummy variables)\nA dummy variable is a numerical representation of a categorical variable. It uses 0s and 1s to encode different groups, which results in level shifts to predictions (just like the intercept). This allows categorical data to be included in regression models.\nFor example, in the Palmer Penguins dataset, the species variable has three categories: Adelie, Chinstrap, and Gentoo. Since regression models require numerical inputs, we create dummy variables for two of the species (the third is treated as the baseline).\nLet‚Äôs define the dummy variables:\n\\[\n\\text{species}_\\text{Chinstrap} =\n\\begin{cases}\n1, & \\text{if the penguin is Chinstrap} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n\\]\n\\[\n\\text{species}_\\text{Gentoo} =\n\\begin{cases}\n1, & \\text{if the penguin is Gentoo} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n\\]\nSince there are three categories, we only need two dummy variables ‚Äî the third category (Adelie) is the reference category.\nMathematically, the multiple regression model with these dummy variables is:\n\\[\n\\text{body\\_mass}_i = \\beta_0 + \\beta_1 \\cdot \\text{species}_\\text{Chinstrap} + \\beta_2 \\cdot \\text{species}_\\text{Gentoo} + \\varepsilon_i\n\\]\nwhere:\n\n\\(\\beta_0\\) represents the average body mass of Adelie penguins (the reference category).\n\\(\\beta_1\\) represents the difference in average body mass between Chinstrap and Adelie penguins.\n\\(\\beta_2\\) represents the difference in average body mass between Gentoo and Adelie penguins.\n\nProgrammatically, the R model formula is:\nlm(Y ~ 1 + X, data = data)\nwhere:\n\nX is a categorical variable (character or factor) which is automatically converted into dummy variable(s).\n\nThis approach allows categorical predictors to be incorporated into regression models while maintaining meaningful interpretation.\n\nExample: Predicting penguin weight using species information\n\nfit_species &lt;- lm(body_mass_g ~ species, data = penguins)\nsummary(fit_species)\n\n\nCall:\nlm(formula = body_mass_g ~ species, data = penguins)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1126.02  -333.09   -33.09   316.91  1223.98 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       3700.66      37.62   98.37   &lt;2e-16 ***\nspeciesChinstrap    32.43      67.51    0.48    0.631    \nspeciesGentoo     1375.35      56.15   24.50   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 462.3 on 339 degrees of freedom\n  (2 observations deleted due to missingness)\nMultiple R-squared:  0.6697,    Adjusted R-squared:  0.6677 \nF-statistic: 343.6 on 2 and 339 DF,  p-value: &lt; 2.2e-16\n\n\nInterpretting the dummy variable coefficients for categorical predictors requires special consideration to the reference category.\n\nIntercept (\\(\\beta_0 \\approx 3700.66\\)):\nThis represents the average body mass (in grams) of Adelie penguins, since Adelie is the reference category. On average, Adelie penguins weigh 3700.66 grams. This is highly statistically significant (p &lt; 0.001), which simply means their weight is statistically not zero.\nspeciesChinstrap (\\(\\beta_1 \\approx 32.43\\)):\nThis represents the difference in average body mass between Chinstrap and Adelie penguins. Chinstrap penguins are, on average, 32.43 grams heavier than Adelie penguins, but this difference is not statistically significant (p = 0.631), meaning we cannot confidently conclude that Chinstrap penguins weigh more than Adelie penguins based on this model.\nspeciesGentoo (\\(\\beta_2 \\approx 1375.35\\)):\nThis represents the difference in average body mass between Gentoo and Adelie penguins. Gentoo penguins are, on average, 1375.35 grams heavier than Adelie penguins, and this difference is highly statistically significant (p &lt; 0.001).\n\nTry adding a second categorical variable for the penguin‚Äôs island into the model, does it make a difference?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nTo model body_mass_g with categorical variables, use both island and species as predictors.\nfit &lt;- lm(body_mass_g ~ island + species, data = penguins)\nsummary(fit)"
  },
  {
    "objectID": "modules/statistics/linear-regression/index.html#interaction-effects",
    "href": "modules/statistics/linear-regression/index.html#interaction-effects",
    "title": "1. Linear regression",
    "section": "Interaction effects",
    "text": "Interaction effects\nAn interaction effect occurs when the effect of one predictor on the response variable depends on the value of another predictor. This means that the relationship between a predictor and the outcome is not constant across levels of another variable.\nMathematically, an interaction between two variables \\(X_1\\) and \\(X_2\\) in a regression model is represented as:\n\\[\nY = \\beta_0 + \\beta_1 X_1 + \\beta_2 X_2 + \\beta_3 (X_1 \\times X_2) + \\varepsilon\n\\]\nwhere:\n\n\\(\\beta_3\\) represents the interaction effect, or how the relationship between \\(X_1\\) and \\(Y\\) changes depending on \\(X_2\\).\n\nProgrammatically we use * to represent interactions, so the R model formula is:\nlm(Y ~ 1 + X1 * X2, data = data)\nThe main effects (X1) and (X2) are automatically included. To specify an interaction without including main effects, we instead use X1:X2.\n\nExample: Interaction between species and flipper length\nLet‚Äôs test whether the relationship between flipper length and body mass differs by species. We include an interaction term between species and flipper_length_mm in the model:\n\nfit_interaction &lt;- lm(body_mass_g ~ species * flipper_length_mm, data = penguins)\nsummary(fit_interaction)\n\n\nCall:\nlm(formula = body_mass_g ~ species * flipper_length_mm, data = penguins)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-911.18 -251.93  -31.77  197.82 1144.81 \n\nCoefficients:\n                                    Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                        -2535.837    879.468  -2.883  0.00419 ** \nspeciesChinstrap                    -501.359   1523.459  -0.329  0.74229    \nspeciesGentoo                      -4251.444   1427.332  -2.979  0.00311 ** \nflipper_length_mm                     32.832      4.627   7.095 7.69e-12 ***\nspeciesChinstrap:flipper_length_mm     1.742      7.856   0.222  0.82467    \nspeciesGentoo:flipper_length_mm       21.791      6.941   3.139  0.00184 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 370.6 on 336 degrees of freedom\n  (2 observations deleted due to missingness)\nMultiple R-squared:  0.7896,    Adjusted R-squared:  0.7864 \nF-statistic: 252.2 on 5 and 336 DF,  p-value: &lt; 2.2e-16\n\n\nThe interaction terms represent how the effect of flipper length on body mass differs by species.\n\nspeciesChinstrap:flipper_length_mm (\\(\\beta_4 \\approx 1.742\\)):\nThis coefficient represents the additional change in body mass for Chinstrap penguins for each additional millimetre of flipper length, compared to Adelie penguins (the reference species). The coefficient is not statistically significant (p = 0.82467), suggesting that the relationship between flipper length and body mass for Chinstrap penguins is not meaningfully different from that of Adelie penguins. The small value of 1.742 indicates that even if the effect were significant, it would be a minor difference in comparison to other species.\nspeciesGentoo:flipper_length_mm (\\(\\beta_5 \\approx 21.791\\)):\nThis coefficient represents the additional change in body mass for Gentoo penguins for each additional millimetre of flipper length, compared to Adelie penguins. The coefficient is statistically significant (p = 0.00184), indicating that the effect of flipper length on body mass for Gentoo penguins is significantly stronger than for Adelie penguins. Specifically, for each additional millimetre of flipper length, the body mass of Gentoo penguins increases by 21.791 grams more than Adelie penguins, reflecting a more pronounced relationship between flipper length and body mass for this species.\n\nNow try to model a penguin‚Äôs weight using the interaction between species and the length of a penguin‚Äôs bill.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse * symbol to include the interaction between species and bill_length_mm in your model.\nfit &lt;- lm(body_mass_g ~ species * bill_length_mm, data = penguins)\nsummary(fit)"
  },
  {
    "objectID": "modules/analysis/tidyr/index.html",
    "href": "modules/analysis/tidyr/index.html",
    "title": "2. Tidy data restructuring",
    "section": "",
    "text": "The idea of tidy data is fundamental to data analysis with the tidyverse. Tidy data describes a clean and principled structure for your data which simplifies analysis tasks. The tidyr package provides tools to maintain or convert datasets into this tidy format, ensuring they integrate smoothly with other tidyverse tools for tasks like visualisation and modelling."
  },
  {
    "objectID": "modules/analysis/tidyr/index.html#tidy-data",
    "href": "modules/analysis/tidyr/index.html#tidy-data",
    "title": "2. Tidy data restructuring",
    "section": "Tidy data",
    "text": "Tidy data\n\nThe tidy data format\nTidy data describes a format for structuring data such that:\n\nEach variable is a column; each column is a variable.\nEach observation is a row; each row is an observation.\nEach value is a cell; each cell is a single value.\n\nThis flat and consistent format makes it easier to perform data manipulation and analysis tasks, especially with other tools from the tidyverse.\nConsider this untidy dataset from the World Health Organization‚Äôs global tuberculosis report:\n\nlibrary(tidyr)\nwho\n\n# A tibble: 7,240 √ó 60\n   country  iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\n   &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n 1 Afghani‚Ä¶ AF    AFG    1980          NA           NA           NA           NA\n 2 Afghani‚Ä¶ AF    AFG    1981          NA           NA           NA           NA\n 3 Afghani‚Ä¶ AF    AFG    1982          NA           NA           NA           NA\n 4 Afghani‚Ä¶ AF    AFG    1983          NA           NA           NA           NA\n 5 Afghani‚Ä¶ AF    AFG    1984          NA           NA           NA           NA\n 6 Afghani‚Ä¶ AF    AFG    1985          NA           NA           NA           NA\n 7 Afghani‚Ä¶ AF    AFG    1986          NA           NA           NA           NA\n 8 Afghani‚Ä¶ AF    AFG    1987          NA           NA           NA           NA\n 9 Afghani‚Ä¶ AF    AFG    1988          NA           NA           NA           NA\n10 Afghani‚Ä¶ AF    AFG    1989          NA           NA           NA           NA\n# ‚Ñπ 7,230 more rows\n# ‚Ñπ 52 more variables: new_sp_m4554 &lt;dbl&gt;, new_sp_m5564 &lt;dbl&gt;,\n#   new_sp_m65 &lt;dbl&gt;, new_sp_f014 &lt;dbl&gt;, new_sp_f1524 &lt;dbl&gt;,\n#   new_sp_f2534 &lt;dbl&gt;, new_sp_f3544 &lt;dbl&gt;, new_sp_f4554 &lt;dbl&gt;,\n#   new_sp_f5564 &lt;dbl&gt;, new_sp_f65 &lt;dbl&gt;, new_sn_m014 &lt;dbl&gt;,\n#   new_sn_m1524 &lt;dbl&gt;, new_sn_m2534 &lt;dbl&gt;, new_sn_m3544 &lt;dbl&gt;,\n#   new_sn_m4554 &lt;dbl&gt;, new_sn_m5564 &lt;dbl&gt;, new_sn_m65 &lt;dbl&gt;, ‚Ä¶\n\n\nThis dataset is structurally untidy since the columns 5 through 60 (prefixed with \"new_\") mix together the diagnosis method, sex, and age group categories. As a result, the columns no longer describe each variable (since many columns are used for the same variable), and each row isn‚Äôt an observation (since rows contain many observations for different methods, genders, and ages).\nUntidy data makes it difficult to perform simple analysis tasks such as comparing the rates of tuberculosis for different age groups, since the calculation would span many columns. A tidy data format as shown below simplifies this operation, since the age variable is now in a singular column that can be easily grouped for comparison summaries.\n\n\nCode for cleaning the who dataset\nlibrary(tidyr)\nwho_tidy &lt;- who |&gt; \n  pivot_longer(\n    cols = starts_with(\"new\"),\n    # Split the names into multiple columns\n    names_to = c(\"diagnosis\", \"sex\", \"age\"),\n    # Use a regular expression where each matching group becomes a column\n    names_pattern = \"new_?(.*)_(.)(.*)\",\n    # Reformat the name columns into factors with better labels\n    names_transform = list(\n      diagnosis = \\(x) factor(x, levels = c(\"rel\", \"sn\", \"sp\", \"ep\"), labels = c(\"Relapse\", \"Negative pulmonary smear\", \"Positive pulmonary smear\", \"Extrapulmonary\")),\n      sex = \\(x) factor(x, levels = c(\"f\", \"m\"), labels = c(\"Female\", \"Male\")),\n      age = \\(x) factor(x, levels = c(\"014\", \"1524\", \"2534\", \"3544\", \"4554\", \"5564\", \"65\"), labels = c(\"0-14\", \"15-24\", \"25-34\", \"35-44\", \"45-54\", \"55-64\", \"65+\"), ordered = TRUE)\n      ),\n    values_to = \"count\",\n    # Drop structurally missing values\n    values_drop_na = TRUE\n  )\n\n\n\nwho_tidy\n\n# A tibble: 76,046 √ó 8\n   country     iso2  iso3   year diagnosis                sex    age   count\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt;                    &lt;fct&gt;  &lt;ord&gt; &lt;dbl&gt;\n 1 Afghanistan AF    AFG    1997 Positive pulmonary smear Male   0-14      0\n 2 Afghanistan AF    AFG    1997 Positive pulmonary smear Male   15-24    10\n 3 Afghanistan AF    AFG    1997 Positive pulmonary smear Male   25-34     6\n 4 Afghanistan AF    AFG    1997 Positive pulmonary smear Male   35-44     3\n 5 Afghanistan AF    AFG    1997 Positive pulmonary smear Male   45-54     5\n 6 Afghanistan AF    AFG    1997 Positive pulmonary smear Male   55-64     2\n 7 Afghanistan AF    AFG    1997 Positive pulmonary smear Male   65+       0\n 8 Afghanistan AF    AFG    1997 Positive pulmonary smear Female 0-14      5\n 9 Afghanistan AF    AFG    1997 Positive pulmonary smear Female 15-24    38\n10 Afghanistan AF    AFG    1997 Positive pulmonary smear Female 25-34    36\n# ‚Ñπ 76,036 more rows\n\n\n\n\nUsing tidy data\nIn the next lesson we will learn how to compute summary statistics with dplyr, such as the total tuberculosis cases by age group. A tidy data format makes it much easier to calculate these summaries.\n\n\n\n\n\n\n\n\n‚ùå Untidy data code\n\n\n\nUntidy data makes it difficult to perform simple calculations.\nSince the age variable is ‚Äòwide‚Äô (spread across many columns), the code needs to write out many column names where it is easy to make a mistake. The resulting table is also ‚Äòwide‚Äô, and lacks any description of what the data shows (age and totals).\n\nlibrary(dplyr)\nwho |&gt; \n  summarise(\n    `0-14` = sum(new_sp_m014, new_sp_f014, new_sn_m014, new_sn_f014, new_ep_m014, new_ep_f014, newrel_m014, newrel_f014, na.rm = TRUE),\n    `15-24` = sum(new_sp_m1524, new_sp_f1524, new_sn_m1524, new_sn_f1524, new_ep_m1524, new_ep_f1524, newrel_m1524, newrel_f1524, na.rm = TRUE),\n    `25-34` = sum(new_sp_m2534, new_sp_f2534, new_sn_m2534, new_sn_f2534, new_ep_m2534, new_ep_f2534, newrel_m2534, newrel_f2534, na.rm = TRUE),\n    `35-44` = sum(new_sp_m3544, new_sp_f3544, new_sn_m3544, new_sn_f3544, new_ep_m3544, new_ep_f3544, newrel_m3544, newrel_f3544, na.rm = TRUE),\n    `45-54` = sum(new_sp_m4554, new_sp_f4554, new_sn_m4554, new_sn_f4554, new_ep_m4554, new_ep_f4554, newrel_m4554, newrel_f4554, na.rm = TRUE),\n    `55-64` = sum(new_sp_m5564, new_sp_f5564, new_sn_m5564, new_sn_f5564, new_ep_m5564, new_ep_f5564, newrel_m5564, newrel_f5564, na.rm = TRUE),\n    `65+` = sum(new_sp_m65, new_sp_f65, new_sn_m65, new_sn_f65, new_ep_m65, new_ep_f65, newrel_m65, newrel_f65, na.rm = TRUE)\n  )\n\n# A tibble: 1 √ó 7\n   `0-14` `15-24` `25-34` `35-44` `45-54` `55-64`   `65+`\n    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 1708251 7642727 9636127 8766716 6500726 4799668 4343303\n\n\n\n\n\n\n\n\n\n\n\n\n‚úÖ Tidy data code\n\n\n\nTidy data makes the code simpler to read and write.\nSince each variable is only specified once in the code, mistakes are less likely and easier to find and fix. The resulting table is also in a ‚Äòlong‚Äô and tidy format, with descriptive column names.\n\nlibrary(dplyr)\nwho_tidy |&gt; \n  group_by(age) |&gt; \n  summarise(total = sum(count))\n\n# A tibble: 7 √ó 2\n  age     total\n  &lt;ord&gt;   &lt;dbl&gt;\n1 0-14  1708251\n2 15-24 7642727\n3 25-34 9636127\n4 35-44 8766716\n5 45-54 6500726\n6 55-64 4799668\n7 65+   4343303"
  },
  {
    "objectID": "modules/analysis/tidyr/index.html#pivoting-with-pivot_longer-and-pivot_wider",
    "href": "modules/analysis/tidyr/index.html#pivoting-with-pivot_longer-and-pivot_wider",
    "title": "2. Tidy data restructuring",
    "section": "Pivoting with pivot_longer() and pivot_wider()",
    "text": "Pivoting with pivot_longer() and pivot_wider()\nPivoting describes changing the structure of the data, where columns are gathered into rows (pivot_longer()) or rows are spread across columns (pivot_wider()).\n\npivot_longer()\nThis function is used to transform a dataset from wide to long format. Untidy data often has variables mixed among many columns (like the who tuberculosis dataset), and pivot_longer() is most useful for cleaning data into a long tidy format.\nThe pivot_longer() function requires two main inputs, the dataset and the columns to pivot.\n\ndata |&gt; \n  pivot_longer(cols = c(col1, col2, col3))\n\nThere are many ways to specify the columns, one way is to write them all inside c(). Usually wide untidy datasets have many columns to pivot (the who dataset has 56), and so writing each column can be tedious and error prone. Fortunately there is a better way, columns can be specified using tidy selection.\n\n\n\n\n\n\nTidy selection\n\n\n\nTidy selection describes a collection of helpful tools for selecting variables:\n\ncol1:col3: select all variables from col1 to col3,\nstarts_with(\"col\")/ends_with(\"x\"): select variables with a start or end string,\ncontains(\"x\")/matches(\"\\\\d+$\"): select variables that contains the string, or matches the regular expression\nand much more!\n\nA comprehensive summary can be found in the ?tidyr_tidy_select documentation.\n\n\nTo tidy the who dataset into a long format, we use pivot_longer() on the wide columns which conveniently all start with \"new\". We can also use names_to and values_to to give better names for the new columns which previously were the names and values of the selected columns.\n\nwho |&gt; \n  pivot_longer(\n    cols = starts_with(\"new\"),\n    names_to = \"diagnosis_sex_age\",\n    values_to = \"count\"\n  )\n\n# A tibble: 405,440 √ó 6\n   country     iso2  iso3   year diagnosis_sex_age count\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;\n 1 Afghanistan AF    AFG    1980 new_sp_m014          NA\n 2 Afghanistan AF    AFG    1980 new_sp_m1524         NA\n 3 Afghanistan AF    AFG    1980 new_sp_m2534         NA\n 4 Afghanistan AF    AFG    1980 new_sp_m3544         NA\n 5 Afghanistan AF    AFG    1980 new_sp_m4554         NA\n 6 Afghanistan AF    AFG    1980 new_sp_m5564         NA\n 7 Afghanistan AF    AFG    1980 new_sp_m65           NA\n 8 Afghanistan AF    AFG    1980 new_sp_f014          NA\n 9 Afghanistan AF    AFG    1980 new_sp_f1524         NA\n10 Afghanistan AF    AFG    1980 new_sp_f2534         NA\n# ‚Ñπ 405,430 more rows\n\n\nSince a wide untidy dataset requires values for every cell, the data has many missing values. After pivoting the data into a longer format, these missing values are no longer structurally required by the data (although they may still be useful or informative). We can remove these missing value rows with the values_drop_na option:\n\nwho |&gt; \n  pivot_longer(\n    cols = starts_with(\"new\"),\n    names_to = \"diagnosis_sex_age\",\n    values_to = \"count\",\n    values_drop_na = TRUE\n  )\n\n# A tibble: 76,046 √ó 6\n   country     iso2  iso3   year diagnosis_sex_age count\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;\n 1 Afghanistan AF    AFG    1997 new_sp_m014           0\n 2 Afghanistan AF    AFG    1997 new_sp_m1524         10\n 3 Afghanistan AF    AFG    1997 new_sp_m2534          6\n 4 Afghanistan AF    AFG    1997 new_sp_m3544          3\n 5 Afghanistan AF    AFG    1997 new_sp_m4554          5\n 6 Afghanistan AF    AFG    1997 new_sp_m5564          2\n 7 Afghanistan AF    AFG    1997 new_sp_m65            0\n 8 Afghanistan AF    AFG    1997 new_sp_f014           5\n 9 Afghanistan AF    AFG    1997 new_sp_f1524         38\n10 Afghanistan AF    AFG    1997 new_sp_f2534         36\n# ‚Ñπ 76,036 more rows\n\n\n\n\n\n\n\n\nSeparating multiple variables in names\n\n\n\nIt is also possible to split the diagnosis_sex_age column into three separate columns using names_sep (for simple delimiters) or names_pattern (for matching regular expressions).\nIn this case values like \"new_sp_m554\", new_sn_f65 and newrel_m5564 are not easily separable by a delimiter, and so a regular expression like \"names_pattern = new_?(.*)_(.)(.*)\" is required.\nAlternatively, we can use separate() to separate a column into multiple columns.\n\n\nThe world_bank_pop dataset contains years across multiple columns, use pivot_longer() to gather all of the year columns into a single \"year\" column with the population values collected into a \"population\" column.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nAll of the year columns can be selected using either:\n\nthe range of columns 2000:2017,\nthe regular expression matches(\\\\d{4}) (4 digits), or\nthe logical test where(is.numeric) to select all columns containing numbers (which is only the year columns)\n\nworld_bank_pop |&gt; \n  pivot_longer(cols = `2000`:`2017`, names_to = \"year\", values_to = \"population\")\n\n\n\n\n\n\npivot_wider()\nConversely, pivot_wider() is used to transform data from long to wide format. This can be useful if your data is untidy because it is too long (multiple variables are contained in rows of a column), or if you‚Äôve completed your analysis and want to nicely present some results in a table of your report.\nThe pivot_wider() function requires two main inputs, the column names for the wider table‚Äôs names and values.\n\ndata |&gt; \n  pivot_wider(\n    names_from = \"names\",\n    values_from = \"values\"\n  )\n\nThe fish_encounters dataset contains sightings of 19 tagged fish as they travel past measurement stations.\n\nfish_encounters\n\n# A tibble: 114 √ó 3\n   fish  station  seen\n   &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n 1 4842  Release     1\n 2 4842  I80_1       1\n 3 4842  Lisbon      1\n 4 4842  Rstr        1\n 5 4842  Base_TD     1\n 6 4842  BCE         1\n 7 4842  BCW         1\n 8 4842  BCE2        1\n 9 4842  BCW2        1\n10 4842  MAE         1\n# ‚Ñπ 104 more rows\n\n\nIt can be useful to treat each measurement station as a separate variable, considering each individual fish as the observational unit (rather than a sighting of a fish at a station).\nFor this we can use pivot_wider() to spread station into the columns with seen as each cell‚Äôs values.\n\nfish_encounters |&gt; \n  pivot_wider(names_from = \"station\", values_from = \"seen\")\n\n# A tibble: 19 √ó 12\n   fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW\n   &lt;fct&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1 4842        1     1      1     1       1     1     1     1     1     1     1\n 2 4843        1     1      1     1       1     1     1     1     1     1     1\n 3 4844        1     1      1     1       1     1     1     1     1     1     1\n 4 4845        1     1      1     1       1    NA    NA    NA    NA    NA    NA\n 5 4847        1     1      1    NA      NA    NA    NA    NA    NA    NA    NA\n 6 4848        1     1      1     1      NA    NA    NA    NA    NA    NA    NA\n 7 4849        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA\n 8 4850        1     1     NA     1       1     1     1    NA    NA    NA    NA\n 9 4851        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA\n10 4854        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA\n11 4855        1     1      1     1       1    NA    NA    NA    NA    NA    NA\n12 4857        1     1      1     1       1     1     1     1     1    NA    NA\n13 4858        1     1      1     1       1     1     1     1     1     1     1\n14 4859        1     1      1     1       1    NA    NA    NA    NA    NA    NA\n15 4861        1     1      1     1       1     1     1     1     1     1     1\n16 4862        1     1      1     1       1     1     1     1     1    NA    NA\n17 4863        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA\n18 4864        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA\n19 4865        1     1      1    NA      NA    NA    NA    NA    NA    NA    NA\n\n\nNotice how the wider form introduces many NA values. These are combinations of fish identifiers and measurement stations which did not have a row in the original dataset. For this dataset, this means that the fish was not seen at the station and we can safely fill these missing values with 0 using the values_fill option:\n\nfish_encounters |&gt; \n  pivot_wider(names_from = \"station\", values_from = \"seen\", values_fill = 0)\n\n# A tibble: 19 √ó 12\n   fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW\n   &lt;fct&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1 4842        1     1      1     1       1     1     1     1     1     1     1\n 2 4843        1     1      1     1       1     1     1     1     1     1     1\n 3 4844        1     1      1     1       1     1     1     1     1     1     1\n 4 4845        1     1      1     1       1     0     0     0     0     0     0\n 5 4847        1     1      1     0       0     0     0     0     0     0     0\n 6 4848        1     1      1     1       0     0     0     0     0     0     0\n 7 4849        1     1      0     0       0     0     0     0     0     0     0\n 8 4850        1     1      0     1       1     1     1     0     0     0     0\n 9 4851        1     1      0     0       0     0     0     0     0     0     0\n10 4854        1     1      0     0       0     0     0     0     0     0     0\n11 4855        1     1      1     1       1     0     0     0     0     0     0\n12 4857        1     1      1     1       1     1     1     1     1     0     0\n13 4858        1     1      1     1       1     1     1     1     1     1     1\n14 4859        1     1      1     1       1     0     0     0     0     0     0\n15 4861        1     1      1     1       1     1     1     1     1     1     1\n16 4862        1     1      1     1       1     1     1     1     1     0     0\n17 4863        1     1      0     0       0     0     0     0     0     0     0\n18 4864        1     1      0     0       0     0     0     0     0     0     0\n19 4865        1     1      1     0       0     0     0     0     0     0     0\n\n\nThe indicator variable of the world_bank_pop dataset contains both population totals and growth. These two values are in principle, two different variables which should be treated as separate columns. After pivoting the year columns into a longer structure, now pivot these population indicator variables into a wider structure to produce a tidy data format.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe indicator variable contains ‚Äòtotal‚Äô and ‚Äògrowth‚Äô variables, which should be made into new columns (names_from). The population variable contains values for these new population totals and growth columns (values_from).\nworld_bank_pop |&gt; \n  pivot_longer(cols = `2000`:`2017`, names_to = \"year\", values_to = \"population\") |&gt; \n  pivot_wider(names_from = \"indicator\", values_from = \"population\")"
  },
  {
    "objectID": "modules/analysis/tidyr/index.html#split-or-combine-columns",
    "href": "modules/analysis/tidyr/index.html#split-or-combine-columns",
    "title": "2. Tidy data restructuring",
    "section": "Split or combine columns",
    "text": "Split or combine columns\nOccasionally the values of single column contains information about multiple variables or observations. Separating this column into multiple columns or rows into a tidy data format (where each column is a variable, and each row is an observation) makes later analysis easier.\n\nseparate_wider_*()\nSeparating combined values into a wider format is appropriate when the values contain information about multiple variables.\nThere are three ways to separate values into columns:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nseparate_wider_position()\nSplits a column into multiple columns using specific position indices, ideal for fixed-width data.\n\n\nseparate_wider_delim()\nDivides a column into new columns based on a specified delimiter, useful for structured patterns.\n\n\nseparate_wider_regex()\nUses regular expressions to separate a column into multiple columns, suitable for complex patterns.\n\n\n\nThe indicator variable from the world_bank_pop dataset encodes multiple variables separated by ..\n\nworld_bank_pop\n\n# A tibble: 1,064 √ó 20\n   country indicator      `2000`  `2001`  `2002`  `2003`  `2004`  `2005`  `2006`\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 ABW     SP.URB.TOTL    4.16e4 4.20e+4 4.22e+4 4.23e+4 4.23e+4 4.24e+4 4.26e+4\n 2 ABW     SP.URB.GROW    1.66e0 9.56e-1 4.01e-1 1.97e-1 9.46e-2 1.94e-1 3.67e-1\n 3 ABW     SP.POP.TOTL    8.91e4 9.07e+4 9.18e+4 9.27e+4 9.35e+4 9.45e+4 9.56e+4\n 4 ABW     SP.POP.GROW    2.54e0 1.77e+0 1.19e+0 9.97e-1 9.01e-1 1.00e+0 1.18e+0\n 5 AFE     SP.URB.TOTL    1.16e8 1.20e+8 1.24e+8 1.29e+8 1.34e+8 1.39e+8 1.44e+8\n 6 AFE     SP.URB.GROW    3.60e0 3.66e+0 3.72e+0 3.71e+0 3.74e+0 3.81e+0 3.81e+0\n 7 AFE     SP.POP.TOTL    4.02e8 4.12e+8 4.23e+8 4.34e+8 4.45e+8 4.57e+8 4.70e+8\n 8 AFE     SP.POP.GROW    2.58e0 2.59e+0 2.61e+0 2.62e+0 2.64e+0 2.67e+0 2.70e+0\n 9 AFG     SP.URB.TOTL    4.31e6 4.36e+6 4.67e+6 5.06e+6 5.30e+6 5.54e+6 5.83e+6\n10 AFG     SP.URB.GROW    1.86e0 1.15e+0 6.86e+0 7.95e+0 4.59e+0 4.47e+0 5.03e+0\n# ‚Ñπ 1,054 more rows\n# ‚Ñπ 11 more variables: `2007` &lt;dbl&gt;, `2008` &lt;dbl&gt;, `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;,\n#   `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, `2013` &lt;dbl&gt;, `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;,\n#   `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;\n\n\nThe first part is always \"SP\" and can be ignored, but the second part is \"POP\" (total population) or \"URB\" (urban population), and the third part is \"TOTL\" (population totals) or \"GROW\" (population growth).\nWe can use separate_wider_delim() to separate indicator based on the \".\" delimiter.\n\nworld_bank_pop |&gt; \n  separate_wider_delim(indicator, delim = \".\", names = c(\"sp\", \"location\", \"indicator\"))\n\n# A tibble: 1,064 √ó 22\n   country sp    location indicator       `2000`  `2001`  `2002`  `2003`  `2004`\n   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 ABW     SP    URB      TOTL          41625    4.20e+4 4.22e+4 4.23e+4 4.23e+4\n 2 ABW     SP    URB      GROW              1.66 9.56e-1 4.01e-1 1.97e-1 9.46e-2\n 3 ABW     SP    POP      TOTL          89101    9.07e+4 9.18e+4 9.27e+4 9.35e+4\n 4 ABW     SP    POP      GROW              2.54 1.77e+0 1.19e+0 9.97e-1 9.01e-1\n 5 AFE     SP    URB      TOTL      115551653    1.20e+8 1.24e+8 1.29e+8 1.34e+8\n 6 AFE     SP    URB      GROW              3.60 3.66e+0 3.72e+0 3.71e+0 3.74e+0\n 7 AFE     SP    POP      TOTL      401600588    4.12e+8 4.23e+8 4.34e+8 4.45e+8\n 8 AFE     SP    POP      GROW              2.58 2.59e+0 2.61e+0 2.62e+0 2.64e+0\n 9 AFG     SP    URB      TOTL        4314700    4.36e+6 4.67e+6 5.06e+6 5.30e+6\n10 AFG     SP    URB      GROW              1.86 1.15e+0 6.86e+0 7.95e+0 4.59e+0\n# ‚Ñπ 1,054 more rows\n# ‚Ñπ 13 more variables: `2005` &lt;dbl&gt;, `2006` &lt;dbl&gt;, `2007` &lt;dbl&gt;, `2008` &lt;dbl&gt;,\n#   `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;, `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, `2013` &lt;dbl&gt;,\n#   `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;\n\n\n\n\nseparate_longer_*()\nSeparating combined values into a longer format is appropriate when a column contains multiple values, for example a clothing product‚Äôs sizes or styles.\nThere are two ways to separate values into rows:\n\n\n\n\n\n\n\nFunction Name\nDescription\n\n\n\n\nseparate_longer_position()\nBreaks a column into multiple rows based on specified fixed positions, useful for expanding fixed-width data.\n\n\nseparate_longer_delim()\nSplits a column into multiple rows using a specified delimiter, ideal for lists or values separated by delimiters.\n\n\n\nConsider this dataset of clothing items:\n\n# Sample dataset of clothing products\nclothing_data &lt;- tibble(\n  item = c(\"T-Shirt\", \"Jacket\", \"Dress\"),\n  size = c(\"S, M, L\", \"M, L, XL\", \"XS, S, M, L\"),\n  colour = c(\"Red, Blue, Green\", \"Black, Grey\", \"Purple, Yellow\")\n)\nclothing_data\n\n# A tibble: 3 √ó 3\n  item    size        colour          \n  &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;           \n1 T-Shirt S, M, L     Red, Blue, Green\n2 Jacket  M, L, XL    Black, Grey     \n3 Dress   XS, S, M, L Purple, Yellow  \n\n\nSince each size and colour is separated by \", \", we can use separate_longer_delim() to separate the multiple product sizes and colours into rows.\n\nclothing_data %&gt;%\n  separate_longer_delim(size, delim = \", \") |&gt; \n  separate_longer_delim(colour, delim = \", \")\n\n# A tibble: 23 √ó 3\n   item    size  colour\n   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; \n 1 T-Shirt S     Red   \n 2 T-Shirt S     Blue  \n 3 T-Shirt S     Green \n 4 T-Shirt M     Red   \n 5 T-Shirt M     Blue  \n 6 T-Shirt M     Green \n 7 T-Shirt L     Red   \n 8 T-Shirt L     Blue  \n 9 T-Shirt L     Green \n10 Jacket  M     Black \n# ‚Ñπ 13 more rows\n\n\n\n\nunite()\nThe unite() function combines multiple columns into a single column, separating the values of each column by a delimiter (by default sep = \"_\"). This is the opposite operation of separate_wider_*().\nIt requires two inputs, the data and columns to combine. The col argument supports tidy selection.\n\ndata |&gt; \n  unite(col = c(col1, col2, col3))\n\nThis is rarely useful for producing tidy data, but it can be useful for preparing data for reports or creating unique identifiers.\n\nlibrary(palmerpenguins)\npenguins %&gt;%\n  unite(col = \"category\", c(species, island, sex), sep = \"_\")\n\n# A tibble: 344 √ó 6\n   category     bill_length_mm bill_depth_mm flipper_length_mm body_mass_g  year\n   &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;int&gt;\n 1 Adelie_Torg‚Ä¶           39.1          18.7               181        3750  2007\n 2 Adelie_Torg‚Ä¶           39.5          17.4               186        3800  2007\n 3 Adelie_Torg‚Ä¶           40.3          18                 195        3250  2007\n 4 Adelie_Torg‚Ä¶           NA            NA                  NA          NA  2007\n 5 Adelie_Torg‚Ä¶           36.7          19.3               193        3450  2007\n 6 Adelie_Torg‚Ä¶           39.3          20.6               190        3650  2007\n 7 Adelie_Torg‚Ä¶           38.9          17.8               181        3625  2007\n 8 Adelie_Torg‚Ä¶           39.2          19.6               195        4675  2007\n 9 Adelie_Torg‚Ä¶           34.1          18.1               193        3475  2007\n10 Adelie_Torg‚Ä¶           42            20.2               190        4250  2007\n# ‚Ñπ 334 more rows"
  },
  {
    "objectID": "modules/analysis/tidyr/index.html#handling-missing-values",
    "href": "modules/analysis/tidyr/index.html#handling-missing-values",
    "title": "2. Tidy data restructuring",
    "section": "Handling Missing Values",
    "text": "Handling Missing Values\nAppropriately representing missing values in your dataset is necessary for an accurate analysis. The tidyr package in R offers several tools for managing missing data, both implicit and explicit. Implicit missing values occur when expected combinations of data are absent, while explicit missing values appear as NA in your dataset.\n\ncomplete()\nThe complete() function transforms implicit missing values (where the row itself is missing) into explicit missing values. It does this by finding all combinations of specified variables, and adding any missing combinations using NA values.\nIt requires two inputs, the dataset and a structure of variables to combine.\n\ndata |&gt; \n  complete(brand, nesting(state, region))\n\nThe nesting() function can limit combinations within other variables, preventing redundant or impossible combinations. The code uses nesting(state, region) to ensure that only existing state-region pairings are considered when filling missing data, preventing improper combinations of regions into other states.\nThe fish_encounters dataset only contains rows where a fish was seen at a measurement station, and so there is an implicit missing value for each time a fish was not observed.\n\nfish_encounters\n\n# A tibble: 114 √ó 3\n   fish  station  seen\n   &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n 1 4842  Release     1\n 2 4842  I80_1       1\n 3 4842  Lisbon      1\n 4 4842  Rstr        1\n 5 4842  Base_TD     1\n 6 4842  BCE         1\n 7 4842  BCW         1\n 8 4842  BCE2        1\n 9 4842  BCW2        1\n10 4842  MAE         1\n# ‚Ñπ 104 more rows\n\n\nWe can use complete() to make these unobserved fish explicit in the data (notice the additional rows, scroll to see them).\n\nfish_encounters |&gt; \n  complete(fish, station)\n\n\n\n# A tibble: 209 √ó 3\n   fish  station  seen\n   &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n 1 4842  Release     1\n 2 4842  I80_1       1\n 3 4842  Lisbon      1\n 4 4842  Rstr        1\n 5 4842  Base_TD     1\n 6 4842  BCE         1\n 7 4842  BCW         1\n 8 4842  BCE2        1\n 9 4842  BCW2        1\n10 4842  MAE         1\n11 4842  MAW         1\n12 4843  Release     1\n13 4843  I80_1       1\n14 4843  Lisbon      1\n15 4843  Rstr        1\n16 4843  Base_TD     1\n17 4843  BCE         1\n18 4843  BCW         1\n19 4843  BCE2        1\n20 4843  BCW2        1\n21 4843  MAE         1\n22 4843  MAW         1\n23 4844  Release     1\n24 4844  I80_1       1\n25 4844  Lisbon      1\n26 4844  Rstr        1\n27 4844  Base_TD     1\n28 4844  BCE         1\n29 4844  BCW         1\n30 4844  BCE2        1\n31 4844  BCW2        1\n32 4844  MAE         1\n33 4844  MAW         1\n34 4845  Release     1\n35 4845  I80_1       1\n36 4845  Lisbon      1\n37 4845  Rstr        1\n38 4845  Base_TD     1\n39 4845  BCE        NA\n40 4845  BCW        NA\n41 4845  BCE2       NA\n42 4845  BCW2       NA\n43 4845  MAE        NA\n44 4845  MAW        NA\n45 4847  Release     1\n46 4847  I80_1       1\n47 4847  Lisbon      1\n48 4847  Rstr       NA\n49 4847  Base_TD    NA\n50 4847  BCE        NA\n# ‚Ñπ 159 more rows\n\n\nSince we know all implicit missing values were cases where the fish wasn‚Äôt seen at the station, we can use fill to give a known value.\n\nfish_encounters |&gt; \n  complete(fish, station, fill = list(seen = 0))\n\n\n\n# A tibble: 209 √ó 3\n   fish  station  seen\n   &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n 1 4842  Release     1\n 2 4842  I80_1       1\n 3 4842  Lisbon      1\n 4 4842  Rstr        1\n 5 4842  Base_TD     1\n 6 4842  BCE         1\n 7 4842  BCW         1\n 8 4842  BCE2        1\n 9 4842  BCW2        1\n10 4842  MAE         1\n11 4842  MAW         1\n12 4843  Release     1\n13 4843  I80_1       1\n14 4843  Lisbon      1\n15 4843  Rstr        1\n16 4843  Base_TD     1\n17 4843  BCE         1\n18 4843  BCW         1\n19 4843  BCE2        1\n20 4843  BCW2        1\n21 4843  MAE         1\n22 4843  MAW         1\n23 4844  Release     1\n24 4844  I80_1       1\n25 4844  Lisbon      1\n26 4844  Rstr        1\n27 4844  Base_TD     1\n28 4844  BCE         1\n29 4844  BCW         1\n30 4844  BCE2        1\n31 4844  BCW2        1\n32 4844  MAE         1\n33 4844  MAW         1\n34 4845  Release     1\n35 4845  I80_1       1\n36 4845  Lisbon      1\n37 4845  Rstr        1\n38 4845  Base_TD     1\n39 4845  BCE         0\n40 4845  BCW         0\n41 4845  BCE2        0\n42 4845  BCW2        0\n43 4845  MAE         0\n44 4845  MAW         0\n45 4847  Release     1\n46 4847  I80_1       1\n47 4847  Lisbon      1\n48 4847  Rstr        0\n49 4847  Base_TD     0\n50 4847  BCE         0\n# ‚Ñπ 159 more rows\n\n\n\n\ndrop_na()\nThe drop_na() function transforms explicit missing values (represented by NA in the dataset) into implicit non-missing values. This is accomplished by removing the entire rows that contain NA values, leaving behind a dataset with only complete observations. It is the natural opposite of complete().\nIt requires two inputs, the dataset and the variables to drop rows with missing values.\n\ndata |&gt; \n  drop_na(col1, col2, col3)\n\n\n\nfill()\nUsed to fill missing values using the previous or next value. This is a type of imputation, and should be done with care as to not introduce bias or inaccuracies into your analysis. The fill() function is particularly useful for data where missing values can logically be assumed to continue from the nearest previous or next observation.\nThe fill() function accepts three inputs, the dataset, columns to fill, and the direction for filling missing values. There are four options for the fill direction:\n\n\n\n.direction\nDescription\n\n\n\n\n\"down\"\nFills NA with the last non-missing value\n\n\n\"up\"\nFills NA with the next non-missing value\n\n\n\"downup\"\nFills ‚Äúdown‚Äù if possible, otherwise uses ‚Äúup‚Äù\n\n\n\"updown\"\nFills ‚Äúup‚Äù if possible, otherwise uses ‚Äúdown‚Äù\n\n\n\nWith fill(), you can specify the direction of the fill with .direction, choosing either \"down\" to propagate the last valid observation forward, \"up\" to carry the next valid observation backward, or both \"downup\" or \"updown\" to fill missing values in more complex patterns. This ensures that imputation respects the data‚Äôs natural progression or sequence and maintains its structural integrity.\n\n\nreplace_na()\nThe replace_na() function allows you to replace NA values with a specific value. It works very similarly to the fill option of the complete() function, where a dataset and list of replacement values for each column is provided.\n\ndata |&gt; \n  replace_na(\n    list(\n      col1 = 0,\n      col2 = FALSE\n    )\n  )"
  },
  {
    "objectID": "modules/writing/quarto-basics/index.html",
    "href": "modules/writing/quarto-basics/index.html",
    "title": "1. Quarto Basics",
    "section": "",
    "text": "Quarto is a free, open-source system that helps you create interactive and reproducible documents easily."
  },
  {
    "objectID": "modules/writing/quarto-basics/index.html#what-is-quarto",
    "href": "modules/writing/quarto-basics/index.html#what-is-quarto",
    "title": "1. Quarto Basics",
    "section": "",
    "text": "Quarto is a free, open-source system that helps you create interactive and reproducible documents easily."
  },
  {
    "objectID": "modules/writing/quarto-basics/index.html#quarto-fundamentals",
    "href": "modules/writing/quarto-basics/index.html#quarto-fundamentals",
    "title": "1. Quarto Basics",
    "section": "Quarto Fundamentals",
    "text": "Quarto Fundamentals\n\n\n\n\n\nQuarto provides a seamless framework for integrating code, text, and visualisations into a single, interactive, and reproducible document. Written in Markdown, Quarto is easy to learn yet powerful enough for complex document creation.\n\n\n\n\n\n\nQuarto: Multi-Language and Multi-Engine\n\n\n\n\n\nQuarto is not only limited to R code chunks, and you can also use Python, Julia, and SQL code chunks in your Quarto documents.\nDespite the name, R Markdown also allows you to write documents containing code from many programming languages. The difference is that R Markdown requires rendering (‚Äòknitting‚Äô) with R, while Quarto doesn‚Äôt!\n\n\n\nQuarto also provides a range of built-in templates that you can use to create documents for different purposes, such as academic papers, presentations, and websites. These templates make it easy to get started with Quarto and create professional-looking documents with minimal effort.\n\nSetting Up Quarto\nIf you‚Äôre using a recent version of RStudio, Quarto will already be installed and ready for you to use. If you have trouble rendering documents, you may need to install or update Quarto - detailed instructions for this can be found here.\nOnce you have installed Quarto, you can create a new Quarto document by:\n\nGo to the File menu in RStudio\nSelect New File &gt; New File &gt; Quarto Document\n\n\n\nChoose the document type: Document, Presentation, or Interactive.\n\n\nA Quarto file is a plain text file with the extension .qmd.\nNow that you‚Äôve got your first quarto document up and ready, let‚Äôs explore some key components! These include:\n\nA YAML header\nChunks of R code\nMarkdown text\n\n\n\nYAML\nWhen you open up your first quarto document, you will notice a block of text up the top that looks something like this:\n\nThis is the YAML header, which contains metadata about your document, including the title, author, and editor. It allows you to edit the document‚Äôs title (currently ‚ÄúUntitled‚Äù), specifies that the output will be in HTML format, and indicates that the document will open in the visual editor by default.\n\n\n\n\n\n\nSource vs Visual Editor\n\n\n\n\n\nRStudio v1.4 or higher includes Visual Markdown editing. Instead of markdown syntax (e.g., bolding with double asterisks), you can format text, add images and insert tables using a toolbar or keyboard commands, similar to a word processor. View sections 28.3 and 28.4 for more detail.\n\n\n\nBeyond the basics, you can add some real handy components to the YAML\n\n\n\nauthor\nFor assignments especially, its good to include your name and potentially student ID with this section in the YAML.\n\n\nsubtitle\nFor reports it may be nice to add a subtitle for further detail.\n\n\ntoc\nA table of contents can be a useful tool in structuring your document. toc-depth specifies the level of headings to include (e.g.¬†toc-depth: 2 includes the top-level headings and second-level headings in the toc.)\n\n\ndate\nIf you‚Äôd like to include the due date or publishing date of the report.\n\n\n\n\n\n\n\n\n\n\n\n\n\nYAML indentation\n\n\n\n\n\nThe structure of a YAML is very particular about indentation, and errors may occur if it is not formatted correctly. If you encounter cryptic error messages about keywords in your YAML then it‚Äôs worth checking the spacing of items carefully. A useful starting point is Quarto‚Äôs getting started documentation.\n\n\n\n\n\nR Code Chunks\nCode chunks refer to sections in the document where you can write and execute code. These chunks are enclosed by three backticks followed by the name of the language you are using (e.g., r for R code). Code chunks can be included in three ways:\n\nKeyboard commands: Ctrl-Alt-ICtrl-Alt-I (Windows) or Cmd-Option-ICmd-Option-I (Mac)\nClicking the Insert button in the toolbar (top right):\n\n\n\n\n\n\n\nTyping the code chunk manually:\n\n\n\n\n\n\nWrite the code you want to include within the chunk and when you run it, the output will be displayed directly below the chunk!\n\n\n\n\n\n\nInline code\n\n\n\n\n\nCode doesn‚Äôt have to be in a chunk! You can also embed the results of code within paragraphs using include code chunks, it looks like this:\nThe approximate value of $\\pi$ is `{r} pi`:\n\nThe approximate value of \\(\\pi\\) is 3.1415927\n\n\n\n\nYou can also add options to the code chunk to control how the code is executed and displayed. For example, you can specify the output format, the width and height of plots, and whether the code should be displayed in the output.\n\n\n\n\n\nLook at the image of the code chunk above, you can see that the chunk has the following options:\nfig-cap: This option allows you to add a caption to the figure.\nfig-width: This option specifies the width of the figure.\necho: This option controls whether the code in the chunk is displayed in the output.\nThese are only a couple examples of options for chunk options, and there are many more available. You can find a full list of chunk options in section 28.5.2 as well as further discussion in Communicating with Quarto."
  },
  {
    "objectID": "modules/writing/quarto-basics/index.html#markdown-text",
    "href": "modules/writing/quarto-basics/index.html#markdown-text",
    "title": "1. Quarto Basics",
    "section": "Markdown text",
    "text": "Markdown text\nIn a Quarto document, you can write text using Markdown syntax. Markdown is a lightweight markup language that allows you to format text using simple and intuitive syntax. You can use Markdown to create headings, lists, links, images, and more.\n\nHeadings\nHeadings are created using the # symbol followed by the heading text. The number of # symbols indicates the level of the heading. For example, # creates a first-level heading, ## creates a second-level heading, and so on.\n\n\nText Formatting\nJust like in any other word processors, you can also format your text. Here are some examples:\n\nBold: **bold** or __bold__\nItalic: *italic* or _italic_\nStrikethrough: ~~strikethrough~~\nCode: `code`\n\n\n\nLists\nUnordered lists can be created using * or -, with indentation used to indent list items.\nNumbered lists can be created with 1., 2., and so on.\nYou can also create checklists by using - [ ] for an empty box and - [x] for a checked box."
  },
  {
    "objectID": "modules/writing/quarto-basics/index.html#rendering-your-document",
    "href": "modules/writing/quarto-basics/index.html#rendering-your-document",
    "title": "1. Quarto Basics",
    "section": "Rendering Your Document",
    "text": "Rendering Your Document\nOnce you have written your document, you can render it to see the output. To render your document you can:\n\nclick the Render button in the toolbar\nuse the keyboard shortcut Ctrl + Shift + K (Windows) or Cmd + Shift + K (Mac)\nrun the quarto::render() function in the console\n\n\n\n\n\n\n\nIn the Terminal via quarto render:\n\n\n\n\n\n\nWhen you render your document, Quarto will execute the code chunks and generate the output. The output will be displayed in the Viewer pane in RStudio, and you can also view the output in a web browser by clicking cog icon next to Render and ticking the Preview in window box."
  },
  {
    "objectID": "modules/writing/quarto-basics/index.html#additional-resources",
    "href": "modules/writing/quarto-basics/index.html#additional-resources",
    "title": "1. Quarto Basics",
    "section": "Additional Resources",
    "text": "Additional Resources\nThese are the more basic of the quarto markdown syntax. For more on how to communicate with quarto, refer to Communicating with Quarto. Additionally, the following resources may be helpful:\n\nGet Started with Quarto\nQuarto Tutorial\nR for Data Science - Quarto\nMarkdown Basics"
  },
  {
    "objectID": "contribute.html#join-the-group-of-contributors",
    "href": "contribute.html#join-the-group-of-contributors",
    "title": "Contribute to StartR",
    "section": "Join the group of contributors",
    "text": "Join the group of contributors"
  },
  {
    "objectID": "modules/analysis/readr/index.html",
    "href": "modules/analysis/readr/index.html",
    "title": "1. Reading data from files",
    "section": "",
    "text": "Data is the core of data analysis, and accurately reading data is the first step of any analysis. There are many data formats and platforms in use, and understanding how to read them efficiently is necessary for working with data in R. Later in your analysis, you often need to share your cleaned dataset or tabulated results with others, and knowing how to write data to appropriate file formats is necessary for effective communication and collaboration.\nThis lesson will teach the basics of file-based data formats, including:"
  },
  {
    "objectID": "modules/analysis/readr/index.html#text-based-data",
    "href": "modules/analysis/readr/index.html#text-based-data",
    "title": "1. Reading data from files",
    "section": "Text-Based Data",
    "text": "Text-Based Data\nText-based data formats are widely used due to their simplicity and compatibility across various platforms, storing data as plain text. The readr package in R is ideal for importing and exporting text-based datasets.\n\nComma-Separated Values (CSV)\nCSV files are popular for representing tabular data, where each line is a row of data and columns are separated by commas.\nYou can open these files in any text editor, which will show you something like this:\nspecies,island,bill_length_mm,bill_depth_mm,flipper_length_mm,body_mass_g,sex\nAdelie,Torgersen,39.1,18.7,181,3750,male\nGentoo,Biscoe,37.8,18.3,174,3400,female\n\n\nReading CSVs\nThe read_csv() function from readr is recommended to read in CSV files. Simply use the function with the file path to the dataset.\nThe raw CSV for the Palmer penguins dataset can be found at system.file(\"extdata/penguins_raw.csv\", package = \"palmerpenguins\"), and it can be imported into R as penguins_csv with this code:\n\nlibrary(readr)\n# Read the raw penguins csv file from palmerpenguins package. \npenguins_csv &lt;- read_csv(system.file(\"extdata/penguins_raw.csv\", package = \"palmerpenguins\"))\n\nRows: 344 Columns: 17\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr  (9): studyName, Species, Region, Island, Stage, Individual ID, Clutch C...\ndbl  (7): Sample Number, Culmen Length (mm), Culmen Depth (mm), Flipper Leng...\ndate (1): Date Egg\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nNotice the message about ‚Äúcolumn specification‚Äù when this dataset is imported. Text-based data needs parsing into appropriate data types, such as integers or characters.\nThe readr package guesses data types for each column automatically. This guessing is usually accurate, but it is strongly recommended that you verify these column types and make any corrections if needed.\nYou can manually specify the column types with col_types, which is safer than relying on guessing. You can generate some starter code for column types based on the guessed types using spec().\n\nspec(penguins_csv)\n\ncols(\n  studyName = col_character(),\n  `Sample Number` = col_double(),\n  Species = col_character(),\n  Region = col_character(),\n  Island = col_character(),\n  Stage = col_character(),\n  `Individual ID` = col_character(),\n  `Clutch Completion` = col_character(),\n  `Date Egg` = col_date(format = \"\"),\n  `Culmen Length (mm)` = col_double(),\n  `Culmen Depth (mm)` = col_double(),\n  `Flipper Length (mm)` = col_double(),\n  `Body Mass (g)` = col_double(),\n  Sex = col_character(),\n  `Delta 15 N (o/oo)` = col_double(),\n  `Delta 13 C (o/oo)` = col_double(),\n  Comments = col_character()\n)\n\n\nThen simply copy this specification (making any necessary changes) into the col_spec argument like so:\n\npenguins_csv &lt;- read_csv(\n  system.file(\"extdata/penguins_raw.csv\", package = \"palmerpenguins\"),\n  col_types = cols(\n    studyName = col_character(),\n    `Sample Number` = col_double(),\n    Species = col_character(),\n    Region = col_character(),\n    Island = col_character(),\n    Stage = col_character(),\n    `Individual ID` = col_character(),\n    `Clutch Completion` = col_character(),\n    `Date Egg` = col_date(format = \"\"),\n    `Culmen Length (mm)` = col_double(),\n    `Culmen Depth (mm)` = col_double(),\n    `Flipper Length (mm)` = col_double(),\n    `Body Mass (g)` = col_double(),\n    Sex = col_character(),\n    `Delta 15 N (o/oo)` = col_double(),\n    `Delta 13 C (o/oo)` = col_double(),\n    Comments = col_character()\n  )\n)\n\nNow the data types will always be accurate, with any incompatible values being converted to NA (with warnings).\n\n\nOther useful importing options\nThe contents of data files can be just as varied as the file formats themselves. The {readr} package provides many useful arguments to handle these variations to accurately read in the values. Read the documentation with ?read_csv for all the details, here are some particularly useful arguments:\n\nskip: Number of lines to skip before reading data, useful for excluding metadata.\nna: Specify how missing values are represented, e.g., na = c(\"\", \"NA\", \"missing\").\nlocale: Specify the language for the data (useful for if dates and text encodings differ).\n\n\n\nWriting CSVs\nThe write_csv() function is used to export data frames to CSV files. Simply pass in the dataset to export, and the file path of where the data should be written.\n# Exporting a data frame to a CSV file\nwrite_csv(penguins_csv, \"output/penguins_processed.csv\")\n\n\nOther text-based formats\nDifferent formats are suited to specific needs, such as varying delimiters or fixed column widths. Here‚Äôs a summary of other file formats and the functions used to import and export them.\n\n\n\n\n\n\n\n\n\nFormat\nRead Function\nWrite Function\nDescription\n\n\n\n\nComma-Separated\nread_csv()\nwrite_csv()\nCommas separate values\n\n\nTab-Separated\nread_tsv()\nwrite_tsv()\nTabs separate values\n\n\nDelimited\nread_delim()\nwrite_delim()\nCustom delimiter specified by user\n\n\nFixed Width Format\nread_fwf()\nN/A\nColumns of fixed widths\n\n\nWhite Space Delimited\nread_table()\nN/A\nSeparated by white space\n\n\n\n\n\nReading multiple files\nFor datasets with similar structures, readr enables you to read them together into a single dataset (optionally with a file identifier).\nSimply use the read_*() function with a vector of file paths, and you can add a column for the file name with id = &lt;file_name_column&gt;."
  },
  {
    "objectID": "modules/analysis/readr/index.html#excel-files",
    "href": "modules/analysis/readr/index.html#excel-files",
    "title": "1. Reading data from files",
    "section": "Excel files",
    "text": "Excel files\nThe read_excel() function from the readxl package is designed to import data from Excel files into R. It supports both .xls and .xlsx formats. Only a single sheet can be read in at a time, and by default the first sheet is read.\n\nlibrary(readxl)\n# Importing data from an Excel file\npenguins_xlsx &lt;- read_excel(\"penguins_data.xlsx\")\n\nThe read_excel() function behaves very similarly to the {readr} functions, but has some additional options specific to excel:\n\nsheet: Specify which sheet to read either with the sheet name (as a string) or the sheet index (as a number).\nrange: This option lets you define a specific cell range to import from the selected sheet, for example \"A1:D10\".\n\nThe {readxl} package does not support writing excel files."
  },
  {
    "objectID": "modules/analysis/readr/index.html#serialised-r-data-formats",
    "href": "modules/analysis/readr/index.html#serialised-r-data-formats",
    "title": "1. Reading data from files",
    "section": "Serialised R Data Formats",
    "text": "Serialised R Data Formats\nIn R, serialised data formats such as RDS and RDA (or RData) are used to efficiently save and load R objects, preserving their structure and metadata. These formats allow you to save and restore any R object, not just datasets, making them a useful format for storing intermediate results.\nSerialised formats provide quick read and write operations because they do not require parsing and deparsing like text-based data formats. The disadvantage of this is that these formats are not designed for use outside the R ecosystem.\nThe readr package supports reading and writing RDS files, with a similar usage to other text-based file formats:\n\nlibrary(readr)\n\n# Writing the penguins data to an RDS file\nwrite_rds(penguins_csv, \"penguins.rds\")\n\n# Reading the penguins data from an RDS file\npenguins_rds &lt;- read_rds(\"penguins.rds\")"
  },
  {
    "objectID": "modules/analysis/dplyr/index.html",
    "href": "modules/analysis/dplyr/index.html",
    "title": "3. Data manipulation",
    "section": "",
    "text": "Data manipulation is used in analysis for improving data quality, exploring data, and calculating summary tables. It involves modifying observations with filters, sorting data, and selecting, renaming, and adding variables. Computing summaries helps derive insights by aggregating data, while joining tables allows for combining multiple datasets into a cohesive singular dataset. Tools from dplyr enable such data manipulation, preparing informative summary tables and making data ready for modelling and visualisation."
  },
  {
    "objectID": "modules/analysis/dplyr/index.html#manipulating-variables",
    "href": "modules/analysis/dplyr/index.html#manipulating-variables",
    "title": "3. Data manipulation",
    "section": "Manipulating Variables",
    "text": "Manipulating Variables\nManipulating variables involves adding new columns, removing unnecessary ones, and renaming existing columns to improve data clarity and relevance. It also includes transforming data by creating derived variables, thereby enhancing the dataset‚Äôs usability for analysis.\n\nSelect variables (select())\nThe select() function allows you to choose specific columns from a dataset.\n\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\n# Select species, island, and bill_length_mm columns\npenguins |&gt;\n  select(species, island, bill_length_mm)\n\n# A tibble: 344 √ó 3\n   species island    bill_length_mm\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;\n 1 Adelie  Torgersen           39.1\n 2 Adelie  Torgersen           39.5\n 3 Adelie  Torgersen           40.3\n 4 Adelie  Torgersen           NA  \n 5 Adelie  Torgersen           36.7\n 6 Adelie  Torgersen           39.3\n 7 Adelie  Torgersen           38.9\n 8 Adelie  Torgersen           39.2\n 9 Adelie  Torgersen           34.1\n10 Adelie  Torgersen           42  \n# ‚Ñπ 334 more rows\n\n\nTry selecting the bill length and depth from the penguins dataset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse select() to extract the bill_length_mm, and bill_depth_mm columns.\npenguins |&gt; \n  select(bill_length_mm, bill_depth_mm)\n\n\n\n\n\n\n\n\n\n\nTidy selection\n\n\n\n\n\nThe select() function supports tidy selection, much like pivot_longer() and many other functions from tidyr.\nThis allowing you to use helpers like starts_with() and contains() to efficiently select columns.\n\n\n\n\n\nRename variables (rename())\nThe rename() function changes the names of existing columns.\n\n# Rename bill_length_mm to bill_length\npenguins |&gt;\n  rename(bill_length = bill_length_mm)\n\n# A tibble: 344 √ó 8\n   species island  bill_length bill_depth_mm flipper_length_mm body_mass_g sex  \n   &lt;fct&gt;   &lt;fct&gt;         &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt;\n 1 Adelie  Torger‚Ä¶        39.1          18.7               181        3750 male \n 2 Adelie  Torger‚Ä¶        39.5          17.4               186        3800 fema‚Ä¶\n 3 Adelie  Torger‚Ä¶        40.3          18                 195        3250 fema‚Ä¶\n 4 Adelie  Torger‚Ä¶        NA            NA                  NA          NA &lt;NA&gt; \n 5 Adelie  Torger‚Ä¶        36.7          19.3               193        3450 fema‚Ä¶\n 6 Adelie  Torger‚Ä¶        39.3          20.6               190        3650 male \n 7 Adelie  Torger‚Ä¶        38.9          17.8               181        3625 fema‚Ä¶\n 8 Adelie  Torger‚Ä¶        39.2          19.6               195        4675 male \n 9 Adelie  Torger‚Ä¶        34.1          18.1               193        3475 &lt;NA&gt; \n10 Adelie  Torger‚Ä¶        42            20.2               190        4250 &lt;NA&gt; \n# ‚Ñπ 334 more rows\n# ‚Ñπ 1 more variable: year &lt;int&gt;\n\n\nTry renaming the columns to remove the units from the variable names.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse rename() to modify column names to remove units, such as changing bill_length_mm to bill_length, bill_depth_mm to bill_depth, flipper_length_mm to flipper_length, and body_mass_g to body_mass.\npenguins |&gt; \n  rename(\n    bill_length = bill_length_mm, \n    bill_depth = bill_depth_mm, \n    flipper_length = flipper_length_mm,\n    body_mass = body_mass_g\n  )\n\n\n\n\n\n\nCompute variables (mutate())\nThe mutate() function creates new columns or modifies existing ones.\n\n# Add a new column for body mass in kilograms\npenguins |&gt;\n  mutate(body_mass_kg = body_mass_g / 1000)\n\n# A tibble: 344 √ó 9\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ‚Ñπ 334 more rows\n# ‚Ñπ 3 more variables: sex &lt;fct&gt;, year &lt;int&gt;, body_mass_kg &lt;dbl&gt;\n\n\nTry creating new columns which convert the bill length, bill depth, and flipper length into centimetres.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse mutate() to convert the millimetre columns to centimetres, for instance, change bill_length_mm to bill_length_cm by dividing by 10.\npenguins |&gt; \n  mutate(\n    bill_length_cm = bill_length_mm / 10,\n    bill_depth_cm = bill_depth_mm / 10,\n    flipper_length_cm = flipper_length_mm / 10\n  )\n\n\n\n\n\n\n\n\n\n\nMutating across multiple columns\n\n\n\n\n\nTo apply the same calculation across multiple columns, use mutate() with across() and tidy selection functions. For instance, you can convert measurements from millimetres to centimetres for all columns ending with ‚Äúmm‚Äù by dividing by 10.\n\npenguins |&gt;\n  mutate(\n    across(\n      # Specify columns with tidy selection\n      .cols = ends_with(\"mm\"),\n      # Calculations on each column\n      .fns = ~ .x / 10, \n      # Name of the new colum (replace mm with cm)\n      .names = \"{sub('mm', 'cm', .col)}\"\n    )\n  )\n\n# A tibble: 344 √ó 11\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ‚Ñπ 334 more rows\n# ‚Ñπ 5 more variables: sex &lt;fct&gt;, year &lt;int&gt;, bill_length_cm &lt;dbl&gt;,\n#   bill_depth_cm &lt;dbl&gt;, flipper_length_cm &lt;dbl&gt;\n\n\nA named list of functions can be provided to compute multiple things across multiple columns."
  },
  {
    "objectID": "modules/analysis/dplyr/index.html#manipulating-observations",
    "href": "modules/analysis/dplyr/index.html#manipulating-observations",
    "title": "3. Data manipulation",
    "section": "Manipulating Observations",
    "text": "Manipulating Observations\n\nExtract rows by condition (filter())\nThe filter() function selects rows based on specific conditions.\n\n# Filter for Adelie species only\npenguins |&gt;\n  filter(species == \"Adelie\")\n\n# A tibble: 152 √ó 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ‚Ñπ 142 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nTry using filter() to keep only penguins with above average flipper lengths.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nFilter the penguins dataset to include only the rows where flipper_length_mm is greater than the mean of flipper_length_mm.\npenguins |&gt; \n  filter(flipper_length_mm &gt; mean(flipper_length_mm, na.rm = TRUE))\n\n\n\n\n\n\nExtract rows by position (slice())\nThe slice() function selects rows by their position.\n\n# Get the first 5 rows\npenguins |&gt;\n  slice(1:5)\n\n# A tibble: 5 √ó 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\n\n\n\n\nSlicing the start and end of the data\n\n\n\n\n\nTo quickly access the top or bottom rows of your data, you can use slice_head() and slice_tail() functions.\n\n# Slice the top 5 rows\npenguins %&gt;%\n  slice_head(n = 5)\n\n# A tibble: 5 √ó 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n# Slice the bottom 10% of rows\npenguins %&gt;%\n  slice_tail(prop = 0.1)\n\n# A tibble: 34 √ó 8\n   species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Chinstrap Dream            49.7          18.6               195        3600\n 2 Chinstrap Dream            47.5          16.8               199        3900\n 3 Chinstrap Dream            47.6          18.3               195        3850\n 4 Chinstrap Dream            52            20.7               210        4800\n 5 Chinstrap Dream            46.9          16.6               192        2700\n 6 Chinstrap Dream            53.5          19.9               205        4500\n 7 Chinstrap Dream            49            19.5               210        3950\n 8 Chinstrap Dream            46.2          17.5               187        3650\n 9 Chinstrap Dream            50.9          19.1               196        3550\n10 Chinstrap Dream            45.5          17                 196        3500\n# ‚Ñπ 24 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nA negative n or prop will remove values from the start or end of the data.\n\n\n\nslice_min() and slice_max() in dplyr help you extract rows with the smallest or largest values of a specific column. This is useful for identifying extremes within your data.\n\n# Find penguins with the smallest bill length\npenguins %&gt;%\n  slice_min(bill_length_mm, n = 3)\n\n# A tibble: 3 √ó 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Dream               32.1          15.5               188        3050\n2 Adelie  Dream               33.1          16.1               178        2900\n3 Adelie  Torgersen           33.5          19                 190        3600\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nTo take a random sample of rows from your dataset, use the slice_sample() function. This is helpful for creating a subset of data for exploratory analysis or testing.\n\n# Randomly slice 10 penguins\npenguins %&gt;%\n  slice_sample(n = 10)\n\n# A tibble: 10 √ó 8\n   species   island   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie    Dream              36            17.1               187        3700\n 2 Chinstrap Dream              43.5          18.1               202        3400\n 3 Chinstrap Dream              49.2          18.2               195        4400\n 4 Adelie    Biscoe             40.6          18.8               193        3800\n 5 Adelie    Biscoe             39            17.5               186        3550\n 6 Adelie    Torgers‚Ä¶           34.6          17.2               189        3200\n 7 Adelie    Biscoe             42.2          19.5               197        4275\n 8 Adelie    Dream              39            18.7               185        3650\n 9 Gentoo    Biscoe             47.2          13.7               214        4925\n10 Gentoo    Biscoe             46.2          14.5               209        4800\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nUse an appropriate slice function to find the 5 heaviest penguins.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse the slice_max() function to find the 5 penguins with the highest body_mass_g, sorting by this variable and specifying n = 5.\npenguins |&gt; \n  slice_max(order_by = body_mass_g, n = 5)\n\n\n\n\n\n\nUnique combinations (distinct())\nThe distinct() function returns unique rows, removing duplicates.\n\n# Get distinct species and islands combinations\npenguins |&gt;\n  distinct(species, island)\n\n# A tibble: 5 √ó 2\n  species   island   \n  &lt;fct&gt;     &lt;fct&gt;    \n1 Adelie    Torgersen\n2 Adelie    Biscoe   \n3 Adelie    Dream    \n4 Gentoo    Biscoe   \n5 Chinstrap Dream    \n\n\nUse distinct() to find which years exist in the dataset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse distinct(year) to find and extract the unique years in the dataset.\npenguins |&gt; \n  distinct(year)\n\n\n\n\n\n\nSort rows (arrange())\nThe arrange() function orders the rows according to one or more columns. You can wrap a variable in desc() to sort that variable in descending order.\n\n# Arrange penguins by bill length in descending order\npenguins |&gt;\n  arrange(desc(bill_length_mm))\n\n# A tibble: 344 √ó 8\n   species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo    Biscoe           59.6          17                 230        6050\n 2 Chinstrap Dream            58            17.8               181        3700\n 3 Gentoo    Biscoe           55.9          17                 228        5600\n 4 Chinstrap Dream            55.8          19.8               207        4000\n 5 Gentoo    Biscoe           55.1          16                 230        5850\n 6 Gentoo    Biscoe           54.3          15.7               231        5650\n 7 Chinstrap Dream            54.2          20.8               201        4300\n 8 Chinstrap Dream            53.5          19.9               205        4500\n 9 Gentoo    Biscoe           53.4          15.8               219        5500\n10 Chinstrap Dream            52.8          20                 205        4550\n# ‚Ñπ 334 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nTry sorting the penguins dataset by species and flipper_length_mm.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse the arrange() function to sort the dataset first by species and then by flipper_length_mm.\npenguins |&gt; \n  arrange(species, flipper_length_mm)"
  },
  {
    "objectID": "modules/analysis/dplyr/index.html#grouped-operations",
    "href": "modules/analysis/dplyr/index.html#grouped-operations",
    "title": "3. Data manipulation",
    "section": "Grouped Operations",
    "text": "Grouped Operations\nThe group_by() function is used to group data by one or more variables for subsequent operations.\n# Group by species and island\npenguins |&gt;\n  group_by(species, island)\nWhile group_by() doesn‚Äôt change any rows or columns of the data itself, it alters how other dplyr functions operate, affecting calculations and transformations.\nGrouped operations are most commonly used with summarise() to calculate aggregated statistics, like averages or totals, for each group. However, group_by() also works seamlessly with other dplyr functions like filter() and mutate(), allowing you to conduct calculations and transformations within each group.\n\n\n\n\n\n\nMutating within groups\n\n\n\n\n\nMutating within groups allows you to transform data based on group-specific calculations. For example, you can determine if a penguin‚Äôs body_mass_g is above average for its species.\n\npenguins |&gt; \n  group_by(species) |&gt; \n  mutate(above_average_mass = body_mass_g &gt; mean(body_mass_g, na.rm = TRUE)) |&gt; \n  ungroup()\n\n# A tibble: 344 √ó 9\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ‚Ñπ 334 more rows\n# ‚Ñπ 3 more variables: sex &lt;fct&gt;, year &lt;int&gt;, above_average_mass &lt;lgl&gt;"
  },
  {
    "objectID": "modules/analysis/dplyr/index.html#summarising-observations",
    "href": "modules/analysis/dplyr/index.html#summarising-observations",
    "title": "3. Data manipulation",
    "section": "Summarising Observations",
    "text": "Summarising Observations\n\nsummarise()\nThe summarise() function in dplyr calculates summary statistics over a dataset, allowing you to condense information into key metrics.\n\n# Calculate summary statistics for flipper length\npenguins %&gt;%\n  summarise(\n    min_flipper = min(flipper_length_mm, na.rm = TRUE),\n    median_flipper = median(flipper_length_mm, na.rm = TRUE),\n    max_flipper = max(flipper_length_mm, na.rm = TRUE)\n  )\n\n# A tibble: 1 √ó 3\n  min_flipper median_flipper max_flipper\n        &lt;int&gt;          &lt;dbl&gt;       &lt;int&gt;\n1         172            197         231\n\n\nThe summarise() function is often combined with group_by(), allowing you to compare summary statistics across different segments of your data.\n\n# Summarise the average bill length for each species\npenguins |&gt;\n  group_by(species) |&gt;\n  summarise(average_bill_length = mean(bill_length_mm, na.rm = TRUE))\n\n# A tibble: 3 √ó 2\n  species   average_bill_length\n  &lt;fct&gt;                   &lt;dbl&gt;\n1 Adelie                   38.8\n2 Chinstrap                48.8\n3 Gentoo                   47.5\n\n\nTry calculating the average body mass by sex for Adelie, Chinstrap, and Gentoo penguins.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nGroup the data by both sex and species before using summarise() to calculate the mean of body_mass_g.\npenguins |&gt; \n  group_by(sex, species) |&gt; \n  summarise(average_body_mass = mean(body_mass_g, na.rm = TRUE))\n\n\n\n\n\n\ncount()\nThe count() function in dplyr is used to tally the number of occurrences of each unique combination of values in specified columns. This is similar to distinct(), which identifies unique cases, but count() provides the number of times each distinct case occurs.\n\n# Count the penguins of each sex for each species\npenguins %&gt;%\n  count(species, sex)\n\n# A tibble: 8 √ó 3\n  species   sex        n\n  &lt;fct&gt;     &lt;fct&gt;  &lt;int&gt;\n1 Adelie    female    73\n2 Adelie    male      73\n3 Adelie    &lt;NA&gt;       6\n4 Chinstrap female    34\n5 Chinstrap male      34\n6 Gentoo    female    58\n7 Gentoo    male      61\n8 Gentoo    &lt;NA&gt;       5\n\n\nTry counting the number of penguins recorded on each island.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse count() to tally the number of penguins recorded for each island specified in the dataset.\npenguins |&gt; \n  count(island)"
  },
  {
    "objectID": "modules/analysis/dplyr/index.html#joining-tables",
    "href": "modules/analysis/dplyr/index.html#joining-tables",
    "title": "3. Data manipulation",
    "section": "Joining Tables",
    "text": "Joining Tables\nThere are several ways to join multiple tables together in dplyr. You can combine data by stacking rows using bind_rows() or by adding columns with bind_cols(). To add new variables based on common identifying columns, you can use mutating joins like left_join(), right_join(), inner_join(), and full_join(). To extract observations based on matching values in a secondary dataset, use the filtering join function anti_join().\n\nCombining data (bind_rows(), bind_cols())\nMultiple datasets with the same variables can be combined by stacking rows using bind_rows(), while datasets with the same observations can be merged by adding columns using bind_cols().\nThese functions combine data without using common identifying keys, and so special care should be taken to ensure that the datasets are compatible (aligned rows and columns). If your datasets do have matching identifying columns, it is safer to use mutating joins instead of bind_cols().\nIt is common for datasets to be provided in multiple files, such as a separate dataset for each year of collection. Since they all have the same set of variables, we can use bind_rows() to combine these datasets together.\n\n\nCode for setting up separate penguins datasets\nlibrary(dplyr)\nlibrary(palmerpenguins)\npenguins_year &lt;- penguins |&gt; \n  group_by(year) |&gt; \n  group_split()\npenguins_2007 &lt;- penguins_year[[1]]\npenguins_2008 &lt;- penguins_year[[3]]\npenguins_2009 &lt;- penguins_year[[2]]\n\n\n\nbind_rows(penguins_2007, penguins_2008, penguins_2009)\n\n# A tibble: 344 √ó 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ‚Ñπ 334 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\nMutating join (left_join(), right_join(), inner_join(), full_join())\nMutating joins add additional variables from one dataset to another based on matching key columns.\n\n\n\n\n\n\n\n\n\nJoin Type\nDescription\nRows Retained from Left Dataset\nRows Retained from Right Dataset\n\n\n\n\nleft_join()\nAdds columns from the right dataset to the left dataset. Keeps all rows from the left dataset, with NA for unmatched right dataset rows.\nAll\nOnly those that match\n\n\nright_join()\nAdds columns from the left dataset to the right dataset. Keeps all rows from the right dataset, with NA for unmatched left dataset rows.\nOnly those that match\nAll\n\n\ninner_join()\nReturns rows that have matching keys in both datasets and adds columns of both datasets to the result.\nOnly those that match\nOnly those that match\n\n\nfull_join()\nCombines all rows from both datasets, treating unmatched keys with NA values in columns from the opposite dataset.\nAll\nAll\n\n\n\nSuppose we have a penguin_info dataset which contains key details about different penguin species, including their scientific name, typical nest type, and conservation status.\n\npenguin_info &lt;- tibble(\n  species = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n  scientific_name = c(\"Pygoscelis adeliae\", \"Pygoscelis antarcticus\", \"Pygoscelis papua\"),\n  nest_type = c(\"Nests made from stones\", \"Nests made from stones\", \"Nests lined with pebbles and vegetation\"),\n  conservation_status = c(\"Least Concern\", \"Least Concern\", \"Least Concern\")\n)\npenguin_info\n\n# A tibble: 3 √ó 4\n  species   scientific_name        nest_type                 conservation_status\n  &lt;chr&gt;     &lt;chr&gt;                  &lt;chr&gt;                     &lt;chr&gt;              \n1 Adelie    Pygoscelis adeliae     Nests made from stones    Least Concern      \n2 Chinstrap Pygoscelis antarcticus Nests made from stones    Least Concern      \n3 Gentoo    Pygoscelis papua       Nests lined with pebbles‚Ä¶ Least Concern      \n\n\nWe can add this additional information about the penguin species to the data using a left_join().\n\npenguins |&gt;\n  left_join(penguin_info, by = \"species\")\n\n# A tibble: 344 √ó 11\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;chr&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ‚Ñπ 334 more rows\n# ‚Ñπ 5 more variables: sex &lt;fct&gt;, year &lt;int&gt;, scientific_name &lt;chr&gt;,\n#   nest_type &lt;chr&gt;, conservation_status &lt;chr&gt;\n\n\nTry to add information about the islands to the penguins dataset. Information from the Dream island was not provided in the supplementary island_info dataset, so use an appropriate join operation that will produce a combined dataset without any missing values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nConsider using an inner_join() for combining the two datasets. This is appropriate because inner_join() will only keep rows with matching values in both datasets. Since the Dream island is not available in island_info, its entries from penguins will be excluded from the final merged dataset.\npenguins |&gt; \n  inner_join(island_info, by = ______)\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe datasets need to be joined on a key column they both have in common. In this case, it is the island column, which links data about islands from both the penguins and island_info datasets.\npenguins |&gt; \n  inner_join(island_info, by = \"island\")\n\n\n\n\n\n\nFiltering join (semi_join(), anti_join())\nFiltering join functions filter the rows in the left dataset based on matching values in the right dataset. Unlike mutating joins, filtering joins do not add additional variables from the right dataset; the right dataset is only used to identify rows to keep or remove.\n\n\n\n\n\n\n\n\n\nJoin Type\nDescription\nRows Retained from Left Dataset\nRows Retained from Right Dataset\n\n\n\n\nsemi_join()\nReturns rows from the left dataset that have matching keys in the right dataset.\nOnly those that match\nNot included in the result\n\n\nanti_join()\nReturns rows from the left dataset that do not have matching keys in the right dataset.\nOnly those without a match\nNot included in the result\n\n\n\nThe anti_join() function filters observations from the first dataset that do not have matching keys in the second dataset. This is useful when you want to identify records in one dataset without corresponding entries in another.\nSuppose we don‚Äôt want to add additional information about the islands, but we are only interested in the islands we have complete data for. We could use a filtering join to keep only the observations with known island information.\n\nisland_info &lt;- tibble(\n  island = c(\"Biscoe\", \"Torgersen\"),\n  coastline_km = c(10, 3),\n  latitude = c(-64.8, -64.8),\n  longitude = c(-63.8, -64.1)\n)\n\npenguins |&gt;\n  semi_join(island_info, by = \"island\")\n\n# A tibble: 220 √ó 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ‚Ñπ 210 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\n\n\n\n\nFinding incomplete data\n\n\n\n\n\nFiltering joins can help you identify implicit missing values in your dataset if you have a second dataset with a complete set of identifying variables. Using anti_join(complete_data, analysis_data) will reveal which observations are missing from your analysis dataset."
  },
  {
    "objectID": "modules/starter/rstudio-basics/index.html",
    "href": "modules/starter/rstudio-basics/index.html",
    "title": "2. RStudio basics",
    "section": "",
    "text": "RStudio is an Integrated Development Environment (IDE) developed by Posit for the R programming language. It is designed for analysing data, and is the most popular coding environment for R. In extension to the usual script editing and console output of other IDEs, RStudio also includes tools for viewing analysis results such as data, plots, and documents.\nStart by opening RStudio on your computer, once loaded it should look like this:\n\nIn the R Console on the left, you should see information about your R installation. If you see something similar, congratulations ‚Äì you‚Äôve successfully installed both R and RStudio as outlined in the previous lesson!\nYou can try out some R code by typing into the R Console, just after the &gt; at the bottom. We‚Äôll get some practice writing R code in the next lesson, but for now you can try:\n\n1 + 1 (Make sure that basic math still applies)\nhist(rnorm(100)) (Histogram of 100 random normally distributed numbers)\n\n\nAny code you write into the R Console is temporary, and will be lost when you restart R or close RStudio. Any code you want to keep should be written into an R script (or an R document, explained in a later lesson).\nTo create an R script, click on the new document drop-down and select ‚ÄúR Script‚Äù (or use the keyboard shortcut Ctrl-Shift-NCtrl-Shift-N):\n\nAn R script is a simple text file which you can write and save your R code in. To run code from an R script, click on the line of code you want to run and then click the Run button (or use the keyboard shortcut Ctrl-EnterCtrl-Enter)\n\nThe code from your R script is ran in the Console, and the result is displayed.\n\n\n\n\n\n\nRunning selected code\n\n\n\n\n\nInstead of running the entire line of code, you can also run specific parts of your code by first highlighting the part you wish to run.\nTry highlighting rnorm(100) before clicking the run button (or using the keyboard shortcut Ctrl-EnterCtrl-Enter)"
  },
  {
    "objectID": "modules/starter/rstudio-basics/index.html#using-rstudio",
    "href": "modules/starter/rstudio-basics/index.html#using-rstudio",
    "title": "2. RStudio basics",
    "section": "",
    "text": "RStudio is an Integrated Development Environment (IDE) developed by Posit for the R programming language. It is designed for analysing data, and is the most popular coding environment for R. In extension to the usual script editing and console output of other IDEs, RStudio also includes tools for viewing analysis results such as data, plots, and documents.\nStart by opening RStudio on your computer, once loaded it should look like this:\n\nIn the R Console on the left, you should see information about your R installation. If you see something similar, congratulations ‚Äì you‚Äôve successfully installed both R and RStudio as outlined in the previous lesson!\nYou can try out some R code by typing into the R Console, just after the &gt; at the bottom. We‚Äôll get some practice writing R code in the next lesson, but for now you can try:\n\n1 + 1 (Make sure that basic math still applies)\nhist(rnorm(100)) (Histogram of 100 random normally distributed numbers)\n\n\nAny code you write into the R Console is temporary, and will be lost when you restart R or close RStudio. Any code you want to keep should be written into an R script (or an R document, explained in a later lesson).\nTo create an R script, click on the new document drop-down and select ‚ÄúR Script‚Äù (or use the keyboard shortcut Ctrl-Shift-NCtrl-Shift-N):\n\nAn R script is a simple text file which you can write and save your R code in. To run code from an R script, click on the line of code you want to run and then click the Run button (or use the keyboard shortcut Ctrl-EnterCtrl-Enter)\n\nThe code from your R script is ran in the Console, and the result is displayed.\n\n\n\n\n\n\nRunning selected code\n\n\n\n\n\nInstead of running the entire line of code, you can also run specific parts of your code by first highlighting the part you wish to run.\nTry highlighting rnorm(100) before clicking the run button (or using the keyboard shortcut Ctrl-EnterCtrl-Enter)"
  },
  {
    "objectID": "modules/starter/rstudio-basics/index.html#the-4-pane-workspace",
    "href": "modules/starter/rstudio-basics/index.html#the-4-pane-workspace",
    "title": "2. RStudio basics",
    "section": "The 4-pane workspace",
    "text": "The 4-pane workspace\n\nThe RStudio workspace is organised into 4 adjustable panes which serve different purposes:\n\nSource Pane (Top-Left) Write your R code in scripts, documents, and web apps here. Each open file is split across tabs.\nConsole Pane (Bottom-Left) The Console is where code is ran, and most results are shown. This pane also has tabs for the Terminal (a code interface to your computer), and background jobs (used for running code in the background).\nEnvironment and Tools Pane (Top-Right) The environment is where your R objects exist. Try running x &lt;- 1:10 which will create an object named x containing the numbers 1 to 10. This newly created object should appear in the environment tab.\nThis pane also includes other tabs containing tools specific to your R project (such as document rendering and version control with git). R projects are explained more in a later lesson. \nFiles, Packages, Help and Outputs Pane (Bottom-Right) This is where most of your visual outputs are shown.\nThis pane contains tabs for many output types:\n\nPlots: View generated plots.\nViewer: View interactive outputs and documents.\nPresentation: View presentation slides.\n\nIt also includes useful tools for writing R code, including:\n\nFiles: Explore your files.\nHelp: View and search documentation for R functions.\nPackages: Manage installed packages.\n\n\n\n\n\n\n\n\nCustomising your workspace\n\n\n\n\n\nThe appearance and layout of your workspace is fully customisable. You can resize each pane by dragging the gaps between panes.\nFurther customisation options can be found in the Tools &gt; Global Options, from there you can switch the RStudio colour theme under Appearance and reorganise the pane tabs under Pane Layout."
  },
  {
    "objectID": "modules/starter/rstudio-basics/index.html#r-packages",
    "href": "modules/starter/rstudio-basics/index.html#r-packages",
    "title": "2. RStudio basics",
    "section": "R packages",
    "text": "R packages\nR packages extend the functionality of R with new functions and datasets. R packages can be managed from the ‚ÄúPackages‚Äù tab of the Output pane. Here you can see the currently installed packages, update them, or install new packages.\n\nTo install a new R package, click on the ‚ÄúInstall‚Äù button to open the ‚ÄúInstall Packages‚Äù pop-up. Then type the name of the package you want to install (e.g.¬†‚Äútidyverse‚Äù) and click ‚ÄúInstall‚Äù (the dependencies checkbox should also be ticked):\n\nYou can use either the ‚ÄúPackages‚Äù tab or directly use the install.packages() function to install packages.\n\nTry installing the palmerpenguins package. It provides a dataset about Antarctic penguins that we‚Äôll be using in many examples. Once you complete the installation pop-up, you should see the Console busily working to download and install the package. Above all of the red text, you will find that R is running install.packages(\"palmerpenguins\") to install the package.\nTo use an installed package, you need to attach it with the library() function. Try loading the palmerpenguins package with library(palmerpenguins). If successful, you will now be able to view the penguins dataset by running the code penguins and view the dataset‚Äôs documentation by running ?penguins.\n\n\n\n\n\n\nUsing packages\n\n\n\n\n\nR packages only need to be installed once, but they need to be attached every time before you use them.\nLoad all of the packages you use at the start of each R script with library().\nExclude (or comment out) install.packages() from your scripts to prevent re-installing packages each time you run your code.\n\n\n\nTry installing and attaching the palmerpenguins package using only code here:"
  },
  {
    "objectID": "modules/starter/installation/index.html#installing-r",
    "href": "modules/starter/installation/index.html#installing-r",
    "title": "1. Installing R and RStudio",
    "section": "Installing R",
    "text": "Installing R\nThe R programming language is available through the Comprehensive R Archive Network (CRAN) website.\n\n\n\n\n\n\n\nDetailed instructions\n\n\n\nSelect your operating system above for more detailed instructions.\n\n\n\n\nWindows\nDownload the R installer:\n\nOpen your web browser and go to the R Project website.\nUnder the ‚ÄúDownload and Install R‚Äù section, click on the ‚ÄúDownload R for Windows‚Äù link.\n\n\n\nOn the next page, click on ‚Äúbase‚Äù to download the base distribution of R.\n\n\n\nClick on the ‚ÄúDownload R x.x.x for Windows‚Äù link (the version number will vary).\n\n\n\nSave the .exe file to your computer (the download should begin automatically).\n\nInstall R:\n\nOnce the .exe file has been downloaded, open the executable file.\n\n\n\nAllow the installer to change your device.\n\n\n\nThe R Setup Wizard will appear. Click Next.\nAccept the license agreement by selecting I Agree.\nChoose the installation path. The default is usually fine (e.g., C:\\Program Files\\R\\R-x.x.x), but you can choose a different directory if you prefer. Click Next.\nSelect components for installation. The default components (which include everything you need) should be fine, so click Next.\nChoose the start menu folder for the R shortcut, or leave it as the default and click Next.\nSelect whether you want to associate R with .R, .Rdata, and .rds files. You can accept the default option and click Next.\nChoose whether to create a desktop shortcut for R. If you want it, leave the box checked and click Next.\nClick Install to begin the installation.\nOnce the installation is complete, click Finish to exit the setup wizard.\n\n\n\n\n\n\n\nInstalling Rtools (optional)\n\n\n\n\n\nRtools is a collection of software tools necessary for building R packages on Windows. If you are creating R packages, or installing R packages from sources it is useful to have Rtools installed.\nRtools includes compilers and other utilities which help install packages from sources which contain C, C++, or Fortran code.\nDownload Rtools:\n\nOpen your browser and go to the Rtools page: Rtools for Windows.\nFind the version of Rtools that matches your version of R (e.g., Rtools43 is compatible with R 4.3.x).\nClick on the download link for the appropriate Rtools version (e.g., Rtools43.exe for R 4.3.x).\n\nInstall Rtools:\n\nAfter downloading the installer, double-click on the .exe file to start the installation process.\nIn the Setup Wizard, select Next.\nAccept the license agreement and click Next.\nChoose the installation path (the default should be fine), then click Next.\nSelect the components to install. The default components should suffice for most users, so click Next.\nChoose whether to add Rtools to your system‚Äôs PATH variable. It is highly recommended to leave this option checked, as it will make Rtools available from the command line. Click Next.\nClick Install to begin the installation process.\nOnce installation is complete, click Finish.\n\n\n\n\n\n\nMacOS\nDownload the R installer:\n\nOpen your web browser and go to the R Project website.\nUnder the ‚ÄúDownload and Install R‚Äù section, click Download R for macOS.\n\n\n\nOn the next page, click the ‚ÄúR-4.x.x.pkg‚Äù link (where ‚Äúx.x‚Äù will be the version number) to download the R installer for macOS. This will download a .pkg file.\n\n\nInstall R:\n\nAfter downloading the .pkg file, open it to start the installation process.\n\n\n\nFollow the on-screen instructions in the installation wizard:\n\nClick Continue.\nRead and agree to the software license.\nClick Install to start the installation.\nIf prompted, enter your macOS administrator password to authorize the installation.\n\n\n\n\nOnce the installation is complete, click Close to exit the installer.\n\n\n\n\n\n\n\nInstalling Xcode (optional)\n\n\n\n\n\nOn macOS, you may need to install Xcode Command Line Tools to compile R packages that require compiled code (such as C, C++, or Fortran). If you are creating R packages, or installing R packages from sources it is useful to have Xcode installed.\nRtools includes compilers and other utilities which help install packages from sources which contain C, C++, or Fortran code.\nInstall Xcode Command Line Tools:\n\nOpen the Terminal application (you can find it via Spotlight search).\nRun the following command to install Xcode Command Line Tools:\nxcode-select --install\nA pop-up will appear prompting you to install the tools. Click Install to proceed.\n\n\n\n\n\n\nLinux\nBelow are instructions for installing R on Ubuntu / Debian systems. For other linux distributions, please refer to these R installation instructions: https://docs.posit.co/resources/install-r.html\n\nOpen a new Terminal window.\nRun the following command to ensure your package list is up-to-date:\nsudo apt update\nInstall the necessary software properties package:\nsudo apt install -y software-properties-common\nAdd the CRAN repository to your list of package sources:\nsudo add-apt-repository \"deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -c | awk '{print $2}')/\"\nImport the CRAN GPG key for package verification:\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9\nUpdate your package list again:\nsudo apt update\nInstall R:\nsudo apt install -y r-base\n\n\n\n\n\n\n\nInstalling r-base-dev (optional)\n\n\n\n\n\nThe r-base-dev package contains development tools and libraries needed to compile R packages from source. It is particularly important when you want to install R packages that require compiling native code (such as C, C++, or Fortran).\nTo install r-base-dev (after installing r-base):\n\nOpen a Terminal window.\nRun the following command to install r-base-dev:\nsudo apt install -y r-base-dev"
  },
  {
    "objectID": "modules/starter/installation/index.html#installing-rstudio",
    "href": "modules/starter/installation/index.html#installing-rstudio",
    "title": "1. Installing R and RStudio",
    "section": "Installing RStudio",
    "text": "Installing RStudio\nThe RStudio can be downloaded from the Posit website. Scroll down to All Installers and Tarballs and download the RStudio version for your operating system.\n\n\n\n\n\n\n\nDetailed instructions\n\n\n\nSelect your operating system above for more detailed instructions.\n\n\n\n\nWindows\nDownload the RStudio Installer:\n\nOpen your web browser and go to the RStudio website.\nUnder the ‚ÄúRStudio Desktop‚Äù section, click on the Download RStudio button.\nYou will be directed to a page where you can select the version of RStudio for your operating system. Select RStudio for Windows.\nClick on the Download RStudio Desktop button to download the installer for Windows. It will download a .exe file.\n\n\nInstall RStudio:\n\nAfter downloading the .exe file, open the executable file.\n\n\n\nAllow the installer to make changes on your computer.\n\n\n\nThe RStudio Setup Wizard will open. Click Next to continue.\nAccept the license agreement by selecting I Agree.\nChoose the installation directory. The default installation path (e.g., C:\\Program Files\\RStudio) should be fine, but you can change it if needed. Click Next.\nSelect whether you want to create a desktop shortcut for RStudio. If you want one, leave the box checked and click Next.\nClick Install to begin the installation.\nOnce installation is complete, click Finish to exit the setup wizard.\n\nLaunch RStudio:\nAfter the installation, you can launch RStudio either by using the desktop shortcut (if you created one) or by searching for ‚ÄúRStudio‚Äù in the Windows Start menu.\n\n\nMacOS\nDownload the RStudio installer:\n\nOpen your web browser and go to the RStudio website.\nScroll down to the ‚ÄúRStudio Desktop‚Äù section and click Download RStudio.\nOn the next page, under RStudio Desktop for macOS, click Download RStudio Desktop (this will download the .dmg file).\n\n\nInstall RStudio:\n\nAfter the .dmg file has downloaded, locate the file and double-click it to open the disk image.\nA new window will appear showing the RStudio application icon. Drag the RStudio icon into your Applications folder.\n\n\n\nOnce the application is copied to the Applications folder, you can close the disk image window.\n\nLaunch RStudio:\nAfter the installation, you can launch RStudio either by double-clicking the RStudio app in the Applications folder or by searching for ‚ÄúRStudio‚Äù in the application launcher.\n\n\nLinux\nDownload the RStudio installer:\n\nOpen your web browser and go to the RStudio Download page.\nScroll down to the ‚ÄúRStudio Desktop‚Äù section and click Download RStudio.\nOn the next page, choose the .deb package for Ubuntu/Debian and download it to your system.\n\nInstall RStudio:\n\nOnce the .deb file has been downloaded, open it with your application manager.\nClick the manager‚Äôs install button, and enter your system password if necessary.\n\nLaunch RStudio:\nAfter the installation, you can launch RStudio either from your application menu or by running rstudio from your Terminal."
  },
  {
    "objectID": "modules/starter/r-basics/index.html",
    "href": "modules/starter/r-basics/index.html",
    "title": "3. R basics",
    "section": "",
    "text": "Artwork by @allison_horst.\nTo use R you‚Äôll need to learn how to write some basic code. Fortunately R is a comparatively simple programming language to learn, it has:\n\na simple and tolerant syntax (this is like the ‚Äògrammar‚Äô of programming languages),\nextensive help resources written for people without programming skills,\nthousands of extension packages that make your analysis easier,\na friendly and supportive community of R users!\n\nYou can code! If you‚Äôve used a calculator you‚Äôve already written code, code is simply instructions made for a computer (like an equation for a calculator).\n\nArtwork by @allison_horst.\n\n\nJust like a calculator, R can be used to perform basic arithmetic (and a whole lot more!). Try out the following examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR is a functional programming language, which means that it primarily uses functions to complete tasks. A function allows you to do much more than basic arithmetic, they can do almost anything!\nExample:\nTo take the natural logarithm of 1, you would write:\n\n\n\n\n\n\n\n\nIn this example:\n\nlog is the name of the logarithm function\n(1) is the input to the function\n\nYou can look at the help file for any R function using ? or help(), try looking at the documentation for log:\n\n\n\n\n\n\n\n\nIn this documentation (scroll down to Usage) you‚Äôll see that the log() function can accept 2 inputs: log(x, base = exp(1)).\nBy default the logarithm‚Äôs base is exp(1) or \\(e\\) (giving the natural logarithm), but you can change this by specifying a different base. Try changing the logarithm‚Äôs base to 10:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe log() function can take an optional base parameter to specify the logarithm‚Äôs base. By default, it uses the natural logarithm (base e), but if you want to compute the logarithm with base 10, you can specify it as follows.\nlog(1, base = 10)"
  },
  {
    "objectID": "modules/starter/r-basics/index.html#using-r",
    "href": "modules/starter/r-basics/index.html#using-r",
    "title": "3. R basics",
    "section": "",
    "text": "Artwork by @allison_horst.\nTo use R you‚Äôll need to learn how to write some basic code. Fortunately R is a comparatively simple programming language to learn, it has:\n\na simple and tolerant syntax (this is like the ‚Äògrammar‚Äô of programming languages),\nextensive help resources written for people without programming skills,\nthousands of extension packages that make your analysis easier,\na friendly and supportive community of R users!\n\nYou can code! If you‚Äôve used a calculator you‚Äôve already written code, code is simply instructions made for a computer (like an equation for a calculator).\n\nArtwork by @allison_horst.\n\n\nJust like a calculator, R can be used to perform basic arithmetic (and a whole lot more!). Try out the following examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR is a functional programming language, which means that it primarily uses functions to complete tasks. A function allows you to do much more than basic arithmetic, they can do almost anything!\nExample:\nTo take the natural logarithm of 1, you would write:\n\n\n\n\n\n\n\n\nIn this example:\n\nlog is the name of the logarithm function\n(1) is the input to the function\n\nYou can look at the help file for any R function using ? or help(), try looking at the documentation for log:\n\n\n\n\n\n\n\n\nIn this documentation (scroll down to Usage) you‚Äôll see that the log() function can accept 2 inputs: log(x, base = exp(1)).\nBy default the logarithm‚Äôs base is exp(1) or \\(e\\) (giving the natural logarithm), but you can change this by specifying a different base. Try changing the logarithm‚Äôs base to 10:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe log() function can take an optional base parameter to specify the logarithm‚Äôs base. By default, it uses the natural logarithm (base e), but if you want to compute the logarithm with base 10, you can specify it as follows.\nlog(1, base = 10)"
  },
  {
    "objectID": "modules/starter/r-basics/index.html#syntax",
    "href": "modules/starter/r-basics/index.html#syntax",
    "title": "3. R basics",
    "section": "Syntax",
    "text": "Syntax\nSyntax is the grammatical rules of a programming language, and while R has a flexible syntax it does have rules.\nJust like on a calculator, it doesn‚Äôt make sense to ask what 3 */ 5 is. So what does R do? Try it!\n\n\n\n\n\n\n\n\nR returns a ‚Äòsyntax error‚Äô because it didn‚Äôt expect a division (/) to occur immediately after multiplication (*). While errors can be intimidating, they‚Äôre really trying to help. A syntax error in R starts with ‚Äúunexpected‚Äù and then describes the part of your code which violates the syntax rules.\n\nSyntax errors are commonly from mismatched quotes ('...', \"...\") or brackets ((...), {...}), and can be tricky to fix. We‚Äôll learn more about fixing errors in the next lesson about troubleshooting.\n\nCode comments\nOne way to make your code easier to understand is to add code comments. Any code after # will be completely ignored by R, allowing you to write helpful notes about what your code is doing. This is especially useful when sharing your code with others (or your future self)!\nAdd a code comment that explains what this code is doing:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nTo include a comment in your code, start with the # symbol followed by your explanatory text. Comments help explain what the code is doing or why certain decisions were made.\n# This calculates the exponential of 1, returning Euler's number (e)\nexp(1)\n\n\n\n\n\n\nThe pipe, |&gt;\nA lot of functions in R (especially tidyverse functions) are designed to be chained together using |&gt; (the pipe). The pipe simply takes the result of the code on the left, and inserts it into the function on the right.\nExample:\n\n\n\n\n\n\n\n\nWriting long chains of code with the pipe makes your code easier to read and can be documented with comments. The equivalent code without the pipe is mean(exp(rnorm(1000))), which you read from the innermost set of brackets outwards. With the pipe, we say rnorm(1000) is ‚Äòpiped‚Äô into the exp() function giving exp(rnorm(1000)) which is then piped into the mean() function.\n\n\n\n\n\n\nThe magrittr pipe, %&gt;%\n\n\n\nYou might encounter a similar looking magrittr pipe (%&gt;%) in examples online. It is included in the magrittr package, and behaves very similarly to the native pipe.\nThe native pipe (|&gt;) was added to R in version 4.1.0 directly into R‚Äôs syntax, and is recommended for use with new code."
  },
  {
    "objectID": "modules/starter/r-basics/index.html#objects",
    "href": "modules/starter/r-basics/index.html#objects",
    "title": "3. R basics",
    "section": "Objects",
    "text": "Objects\nObjects are used to store data in R, which can be recalled later for use in other code.\nYou can create an object with the assignment operator &lt;-. You can also use =, but we recommend sticking to &lt;- since = is also used for named function inputs.\n\n\n\n\n\n\n\n\nIf successful, it will look like nothing has happened because objects are created silently (no output messages). In RStudio, you will be able to see e added to your environment pane (top-right) with the value 2.7182818.\nThis object can be reused in other code, for example try computing the logarithm of e:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nTo compute the natural logarithm of Euler‚Äôs number ( e ), re-use the e variable you have previously defined. Recall that ( e ) can be represented by exp(1) which you‚Äôll use as follows:\ne &lt;- exp(1)\nlog(e)\n\n\n\n\n\nObject naming\nA clear and descriptive object name is an important for your code to be readable, maintainable, and less error-prone.\nThere are two main styles commonly used in R:\n\n\n\n\n\n\nsnake_case (recommended)\n\n\n\nWords are separated by underscores (_).\nExample:\ntotal_sales &lt;- 1500\naverage_temperature &lt;- 23.5\n\n\n\n\n\n\n\n\ncamelCase\n\n\n\nThe first word is lowercase, and subsequent words start with a capital letter.\nExample:\ntotalSales &lt;- 1500\naverageTemperature &lt;- 23.5\n\n\n\n\n\nArtwork by @allison_horst.\nYou can use any object name you like (R doesn‚Äôt care), but we recommend that you:\n\nBe concise and descriptive\nNo-one likes to write out a really_long_object_name, however a clearly described variable is far better than x and y.\nSpell out all relevant details, for example temperature_celsius is better than temperature or temp (which can be confused for temporary).\nBe consistent\nChoose a naming convention (we recommend snake_case) and stick to it.\nAvoid existing names\nTry not to use names that are already used in R, especially not reserved words like TRUE and FALSE.\nCommon conflicting names include dt and df, which are the densities of t and F distributions (not abbreviations of data or data.frame).\nUse underscores only, no other special characters\nA lot of special characters (e.g.¬†$, @, !, ., #) have special meanings in R, and should not be used.\nFun fact: Until R v2.0.0 (October 2004), underscore was the assignment operator!\n\n\n\nData types\nEach object in R has a type, here are some commonly used data types:\n\nNumeric: 42, 3.14\nWith sub-types:\n\nInteger: 42L (without decimals, the L indicates integer)\nDouble: 3.14 (with decimals)\n\nCharacter: \"startr\"\nLogical: TRUE and FALSE\nDate and Time: Sys.Date() and Sys.time()\n\nR also supports some special data types commonly used in statistics and data analysis:\n\nMissing values: NA\nEach data type can contain NA (not available) to indicate unknown values.\nComplex: 1 + 2i\nComplex numbers consist of real and imaginary parts.\n\nYou can check the data type of a variable with the class() function, and check if an object is a particular type with is.*() (for example is.numeric() and is.logical()).\n\n\nMixing data types\nR automatically converts between data types for you as needed, generally this is helpful and works well but it can sometimes be surprising.\nExperiment with combining different types of data mathematically, and try to reason why you get each result.\n\n\n\n\n\n\n\n\nMany of these mixed data type operations convert one type into another, in the above example:\n\n1L + 3.5: the integer (1L) became a double (1.0)\nTRUE + 3: the logical (TRUE) became numeric/double (1.0)\n\nYou can explicitly convert an object into a different type using as.*() functions (for example as.numeric() and as.character())."
  },
  {
    "objectID": "modules/starter/r-basics/index.html#vectors-matrices-and-arrays",
    "href": "modules/starter/r-basics/index.html#vectors-matrices-and-arrays",
    "title": "3. R basics",
    "section": "Vectors, matrices and arrays",
    "text": "Vectors, matrices and arrays\nThese objects contain multiple values of the same data type, organised into 1D vectors, 2D matrices or higher dimensional arrays.\n\nVectors\nA vector can contain multiple (0 or more) values of the same data type. Vectors are used extensively in R since datasets typically contain more than one observation! A singular value (usually a ‚Äòscalar‚Äô in other languages) is handled as a length 1 vector, so all of the previous examples have used R vectors.\nThe c() function (the combine function) is used to combine multiple vectors together.\n\n\n\n\n\n\n\n\nYou can also generate sequences with seq(), or simply with from:to for integer sequences.\n\n\n\n\n\n\n\n\nSome other useful vector functions include:\nMathematical Summaries:\n\nsum(): Calculate the total of all elements.\n\nmean(): Compute the average value.\nany(): Check if any element is TRUE.\n\nall(): Check if all elements are TRUE.\n\nmin(): Find the minimum value.\n\nmax(): Find the maximum value.\n\nmedian(): Compute the middle value.\n\nquantile(): Compute specified quantiles.\n\nsd(): Calculate the standard deviation.\n\nvar(): Compute the variance.\n\nprod(): Calculate the product of all elements.\n\nCumulative maths:\n\ncumsum(): Compute the cumulative sum of elements.\n\ncumprod(): Compute the cumulative product of elements.\n\ndiff(): Calculate the differences between consecutive elements.\n\nVector Manipulation :\n\nrep(): Replicate elements in the vector.\nsort(): Sort elements in ascending or descending order.\n\nrev(): Reverse the order of elements.\n\nlength(): Get the number of elements in the vector.\ntable(): Create a frequency table of elements.\n\nSet Operations:\n\nunion(): Combine elements from two vectors, removing duplicates.\n\nintersect(): Find common elements between two vectors.\n\nsetdiff(): Find elements in one vector that are not in another.\n\nsetequal(): Check if two vectors contain the same elements (ignoring order).\n\nduplicated(): Identify duplicate elements in a vector.\n\nunique(): Extract unique elements from a vector.\n\n\nTry some of these functions out on these vectors:\n\n\n\n\n\n\n\n\nWhat happens when you try math operations such as + and * between random_integers and random_numbers?\n\n\nMatrices\nA matrix is a 2-dimensional data structure where all elements must be of the same type (e.g., numeric, character). A matrix is constructed with the matrix() function:\n\nmatrix(data, nrow, ncol, byrow = FALSE)\n\ndata: A vector to fill the matrix.\n\nnrow: Number of rows.\nncol: Number of columns.\nbyrow: Whether data fills the matrix row-wise (TRUE) or column-wise (FALSE).\n\n\nTry to create a matrix with 26 rows and 2 columns, containing all lower case letters in the first column and upper case LETTERS in the second column.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nTo create a matrix, use the matrix() function. You need to fill the matrix with c(letters, LETTERS), setting the number of rows to 26 and the number of columns to 2:\nmatrix(c(letters, LETTERS), nrow = 26, ncol = 2)\n\n\n\n\nSome useful functions for working with matrices includes:\n\ndim(): Get the dimensions (rows and columns) of the matrix.\n\nnrow(), ncol(): Get the number of rows or columns, respectively.\n\ncbind(), rbind(): Combine vectors/matrices together by columns or rows.\nrowSums(), colSums(): Compute the sum of each row or column.\n\nrowMeans(), colMeans(): Compute the mean of each row or column.\n\nt(): Transpose the matrix (swap rows and columns).\n\ndiag(): Extract or set the diagonal of a matrix.\n\nx %*% y: Perform matrix multiplication of x and y.\n\n\n\nArrays\nArrays are similar to matrices, but extend to higher dimensional structures. They are created with the array() function:\n\narray(data, dim)\n\ndata: A vector to fill the matrix.\n\ndim: A vector of dimension sizes.\n\n\n\n\nIndexing and Slicing\nThe index of a vector (or matrix/array) is the position of each element. Indexing refers to the extraction of a specific value from a vector using its index (position). Relatedly, slicing extracts 0 or more values from the vector.\nMathematically, this is equivalent to \\(x_i\\) where \\(x\\) is your vector and \\(i\\) are the index position(s) to extract. Indexing and slicing starts from 1 in R (other languages start from 0), so the first value is at index 1 and the last value is at index length(x).\nTo index/slice a vector, we use single square brackets: x[i], where x is your vector and i is a vector of positions to extract.\nTry to find the 13th letter of the alphabet by indexing the letters object:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse indexing with square brackets [] to access elements at a specific position in a vector. For example, to get the 13th letter of the alphabet from the letters vector:\nletters[13]\n\n\n\n\nNow try to slice the first 10 letters by constructing a numeric sequence with seq():\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe sequence of integers from 1 to 10 can be created with this code\nseq(1, 10)\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nTo slice and obtain a sequence of elements, such as the first 10 letters, use the seq() function within the indexing brackets to generate a sequence from 1 to 10.\nletters[seq(1, 10)]\n\n\n\n\n\n\n\n\n\n\nOther indices\n\n\n\n\n\nYou can also use logical values as your index, which will keep values if the index is TRUE.\nNegative indices can also be used, which will remove those positions from the vector.\n\n\n\nYou can also index/slice matrices and arrays, you simply need to specify more dimensions inside the square brackets. For a matrix it is x[rows, cols], and for an array you would use x[i, j, k, ...] for each dimension.\nThe volcano matrix details the topography of Auckland‚Äôs Maunga Whau volcano, extract the first 10 rows and columns 43 to 51.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nTo extract a subset of a matrix with specific rows and columns, use the matrix indexing with a range. For example, to get rows 1 to 10 and columns 43 to 51:\nvolcano[1:10, 43:51]\n\n\n\n\n\n\n\n\n\n\nSlicing only one dimension\n\n\n\n\n\nWhen slicing only one dimension (e.g.¬†only rows keeping all columns), you can omit the unused dimension from the square brackets. For example, volcano[1:10,] will keep the first 10 rows and all columns of the volcano matrix. Similarly, volcano[,43:51] will keep all rows and slice columns 43 to 51 from the matrix.\nIf you slice only one column or row (e.g.¬†volcano[1,] for the first row only), R will simplify the result into a vector. This can be problematic if you‚Äôre doing matrix multiplication, so it can be useful to use volcano[1,,drop = FALSE] to prevent dropping the matrix class."
  },
  {
    "objectID": "modules/starter/r-basics/index.html#data-frames-and-lists",
    "href": "modules/starter/r-basics/index.html#data-frames-and-lists",
    "title": "3. R basics",
    "section": "Data frames and lists",
    "text": "Data frames and lists\n\nLists\nA list is a type of object that can contain different types of data. Lists are constructed with list(...), and the list contents can be named. For example:\n\n\n\n\n\n\n\n\nYou can see that lists can contain anything, and of any length. The date in the example above has a different length and data type from the letters.\n\n\nData frames\nA data.frame is very similar to a list, but it requires all vectors (of possibly different types) to have the same length (the number of rows in the data). Data frames can be constructed with the data.frame() function, where each column or the dataset is a vector used in this function.\n\n\n\n\n\n\n\n\nYou can see that the data.frame has 26 rows and that today‚Äôs date has been replicated to fit the dataset.\nA data frame is one of the most commonly used data structures in R for storing data. It is similar to a matrix, but it allows you to store different types of data (numeric, character, logical, etc.) in different columns.\nData frames are usually created by importing data files, the most common data format is CSV (comma separated values) which can be read in with read.csv(). More information about reading data can be found in the data reading lesson.\nMany packages also come with datasets for demonstrating examples, we‚Äôll be using the penguins data.frame from the palmerpenguins package:\n\n\n\n\n\n\n\n\n\n\nIndexing, slicing, and extracting\nLists and data frames can also be indexed and sliced using single square brackets (x[i]). Lists are 1D (like vectors), and data frames are 2D (like matrices).\nIt is also possible to extract a column/vector out of lists and data frames. This is accomplished using double square brackets (x[[3]], or x[[\"column\"]]) or the dollar sign for named columns (x$column).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nTo extract columns in a data frame, you can use either double square brackets [[]] for column indexing by position or the dollar sign $ for extraction by column name.\n\nFor the 2nd column, use:\n\npenguins[[2]]\n\nFor extracting the flipper_length_mm column, use:\n\npenguins$flipper_length_mm"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Monash EBS Modules",
    "section": "",
    "text": "Getting started \n  \n\n\n\n\n 1. Installing R and RStudio   Install R and RStudio on Windows, macOS, or Linux.    20 minutes        Beginner  \n\n\n 2. RStudio basics   Learn how to use RStudio and install R packages.    15 minutes        Beginner  \n\n\n 3. R basics   Start writing R code with basic functions and mathematical operations. Learn code syntax, chain functions together with the pipe (|&gt;), and understand the different types of data that can exist together in a dataset.    20 minutes        Beginner  \n\n\n 4. Projects and paths   Establish good practices for organising and accessing project files. Essential for when you share your work with others.    20 minutes        Beginner  \n\n\n 5. Strategies for troubleshooting in R   With coding comes bugs and errors that need troubleshooting. In this chapter, you will learn how to decipher errors, find help for fixing them, and practice asking clear questions with minimally reproducible examples.    30 minutes        Beginner  \n\n\n\nNo matching items\n\n\n\n\n\n\n\n\n   Tidy data analysis \n  \n\n\n\n\n 1. Reading data from files   Reading and writing data from common local file formats    15 minutes        Beginner  \n\n\n 2. Tidy data restructuring   How to restructure a messy dataset with tidyr into tidy data.    30 minutes        Intermediate  \n\n\n 3. Data manipulation   How to modify a dataset with dplyr to compute new columns or summaries, change rows or columns, and join datasets together.    45 minutes        Intermediate  \n\n\n\nNo matching items\n\n\n\n\n\n\n\n\n  Statistical modelling\n  \n\n\n\n\n 1. Linear regression   Statistically summarise relationships between variables of a dataset with a linear regression model.    30 minutes        Intermediate  \n\n\n\nNo matching items\n\n\n\n\n\n\n\n\n  Writing documents\n  \n\n\n\n\n 1. Quarto Basics   With Quarto, creating documents and reports becomes a breeze. In this chapter, you will learn how to set up Quarto, explore its key features, and start creating your own quarto documents with ease.    30 minutes        Beginner  \n\n\n\nNo matching items\n\n\n\n\n\nThe team\nContribute\nAbout\nBuilt with Quarto"
  }
]